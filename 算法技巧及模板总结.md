#  算法技巧及模板总结

##  二分查找

以34.在排序数组中查找元素的第一个和最后一个位置经典题目为例，这的`lower_bound()`函数是用来求第一个大于等于target的下标，这一个函数其实能解决大部分问题，主要有大于等于、大于、小于、小于等于，但是都能够通过这一个函数转化过来

**左闭右闭**

```cpp
//左闭右闭写法 [l, r]
int lower_bound1(vector<int>& nums, int target) {
    int l = 0, r = nums.size()-1;
    //区间没有元素的状态是l>r 那么上一个状态(l<=r)就是循环条件
    while(l <= r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid+1;
        else r = mid-1;
    }
    return l;
}
```



**左闭右开**

```cpp
//左闭右开写法 [l, r)
int lower_bound2(vector<int>& nums, int target) {
    int l = 0, r = nums.size();
    //区间没有元素的状态是l==r 那么上一个状态(l<r)就是循环条件
    while(l < r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid+1;
        else r = mid;   //哪边是开区间，那边就不需要1
    }
    return l;   //return r也行
}
```



**左开右开**

```cpp
//左开右开写法 (l, r)
int lower_bound3(vector<int>& nums, int target) {
    int l = -1, r = nums.size();
    //区间没有元素的状态是l+1==r 那么上一个状态(l+1<r)就是循环条件
    while(l+1 < r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid;
        else r = mid;   //哪边是开区间，那边就不需要1
    }
    return l+1; //return r也行
}
```

通过这几种写法的特点，我总结了几个规律：

1、确定区间，三种区间的表达方式
2、循环条件的判断：先想好区间没有元素的状态 那么上一个状态就为循环条件，只改运算符即可
3、防止溢出`mid = l+(r-l)/2`
4、哪边是开区间哪边就不能加一
5、第一个if语句干脆全都写成`if(nums[mid] < target) l = ...`省略号处更具区间开闭情况来判断是否加一
6、最后返回的下标，看循环不变量