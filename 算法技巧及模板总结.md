#  算法技巧及模板总结

##  二分

###  二分查找

以34.在排序数组中查找元素的第一个和最后一个位置经典题目为例，这的`lower_bound()`函数是用来求第一个大于等于target的下标，这一个函数其实能解决大部分问题，主要有大于等于、大于、小于、小于等于，但是都能够通过这一个函数转化过来

**左闭右闭**

```cpp
//左闭右闭写法 [l, r]
int lower_bound1(vector<int>& nums, int target) {
    int l = 0, r = nums.size()-1;
    //区间没有元素的状态是l>r 那么上一个状态(l<=r)就是循环条件
    while(l <= r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid+1;
        else r = mid-1;
    }
    return l;
}
```



**左闭右开**

```cpp
//左闭右开写法 [l, r)
int lower_bound2(vector<int>& nums, int target) {
    int l = 0, r = nums.size();
    //区间没有元素的状态是l==r 那么上一个状态(l<r)就是循环条件
    while(l < r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid+1;
        else r = mid;   //哪边是开区间，那边就不需要1
    }
    return l;   //return r也行
}
```



**左开右开**

```cpp
//左开右开写法 (l, r)
int lower_bound3(vector<int>& nums, int target) {
    int l = -1, r = nums.size();
    //区间没有元素的状态是l+1==r 那么上一个状态(l+1<r)就是循环条件
    while(l+1 < r) {
        int mid = l+(r-l)/2;
		if(nums[mid] >= target) r = mid;
        else l = mid;
    }
    return r
}
```



```cpp
//左开右开写法 (l, r)
int lower_bound3(vector<int>& nums, int target) {
    int l = -1, r = nums.size();
    //区间没有元素的状态是l+1==r 那么上一个状态(l+1<r)就是循环条件
    while(l+1 < r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid;
        else r = mid;   //哪边是开区间，那边就不需要1
    }
    return l+1; //return r也行
}
```

通过这几种写法的特点，我总结了几个规律：

1、确定区间，三种区间的表达方式
2、循环条件的判断：先想好区间没有元素的状态 那么上一个状态就为循环条件，只改运算符即可
3、防止溢出`mid = l+(r-l)/2`
4、哪边是开区间哪边就不能加一
5、第一个if语句干脆全都写成`if(nums[mid] < target) l = ...`省略号处更具区间开闭情况来判断是否加一
6、最后返回的下标，看循环不变量



###  二分答案

二分答案分为两种，求最小和求最大，这有点联想到高中的知识了，求最小我们就需要找大于等于的式子，求最大就需要找小于等于的式子。



**求最小**

今天刷了二分答案求最小，算是打开新世界的大门了，有多了一个求最小的方法了，刷到的这几个题都感觉有一个特点，应该也可以算得上是单调性吧，然后就是一定要会写check函数，然后呢check函数的返回值与二分的答案的正关系或者负关系要理清，这对应在二分的时候对边界的修改是不同的，所以我觉得要判断这一点很重要，其次就是二分答案的初始化一定要写对，今天也在这里栽了跟头。



**求最大**

大致和求最小相反，找到的规律和如何记忆放在下面了



**区分求最大、最小**

当已经分析到能够用二分答案的写法来解决这一题的时候需要思考一下步骤：先看答案求的是最大还是最小，这样可以先判断出是二分最小的方法还是二分最大的方法，其次找到题干中的另外一个限定条件，这通常就是check函数的结果，只有check函数写对了，边界才能正确的移动，边界如何移动就需要判断是求最大还是最小

以开区间为例：
求最小：`check(mid) == true ===> r = mid，最后返回r`
求最大：`check(mid) == true ===> l = mid，最后返回l`
什么情况才是true呢？这就要从题目中找了，通常在给定的另一个参数的限定，比如875给了一个参数`int h`，题干中最后问： 返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k` ，这里的限定就是<=h，那么二分答案的时候check里计算sum的时候如果最后的sum<=h那么就为true
怎么确定左右边界的初始值？----得先看是求最小还是求最大，以求最小为例，最后返回的是r，所以就以r为视角去找能够取的最大和最小值，注意那么右边界其实可以无限大，只需要左边界是r取得的最小值-1即可。
同理求最大就以l为视角，右边界就为l能取的最大值+1







##  滑动窗口

###  定长滑动窗口

这种一般题干中会给出滑动窗口的长度k，然后让你求出所有这些长度的滑动窗口中的最大、最小、子数组数目。最大或者最小可能是平均值、和、距离值等等，一般这种定长滑动窗口相对简单，如果想出来的是一个n^2的复杂度的方法肯定是不能ac这一题的，滑动窗口的复杂度是O(n)的，总结的模板大致分为三个步骤：入、维护答案、出。通常滑动窗口类型的题目需要借助哈希表来达到`元素相同个数`，`元素不同个数`这种条件。

```cpp
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        long long ans = 0, sum = 0;
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            cnt[nums[i]]++;	//入
            if(i < k-1) continue;	//没有达到窗口大小直接跳过后面的步骤
            if(cnt.size() == k) ans = max(ans, sum);	//维护答案
            int out = nums[i-k+1];
            sum -= out;
            if(--cnt[out] == 0) cnt.erase(out);	//出
        }
        return ans;
    }
};
```



###  不定长滑动窗口

这种类型的考法就相对来说比较多了，主要分为三类： 求最长子数组，求最短子数组，以及求子数组个数 ，然后经过这一次的周赛(9.29)，求子数组个数又可以细分成：越长越合法(ans+=l)、越短越合法(ans+=r-l+1)、恰好型滑动窗口。对于恰好型滑动窗口就可以把问题转化成两个至多或者两个至少的问题，如果转化成两个至少的问题，那么恰好k就可以表示成 `f(k) - f(k + 1) `，如果转化成两个至多的问题，那么恰好k就可以表示成`f(k)-f(k-1)`



##  dfs和bfs

力扣平台有时候给你的就是一个邻接表，这意味着它直接帮你初始化邻接表了就只需要管如何搜索就行了，但是对于其它的平台就都需要自己初始化邻接表，下面是初始化邻接表的代码示范：
表示x点和y点有边的邻接表

```cpp
vector<vector<int>> adj(n);	//这个n一定不能忘
for (auto &edge : edges) {
    int x = edge[0], y = edge[1];
    adj[x].emplace_back(y);
    adj[y].emplace_back(x);
}
```



除此之外，有时候也可以初始化一个二维矩阵，比如g[i] [j] = 1表示点i和j有关系，这样的情况就不需要像上面的操作了，就直接搜索这个二维矩阵就行了



###  dfs求连通块个数

```cpp
vector<bool> visited(n, false);
function<int(int)> dfs = [&](int i) -> int{
    int sz = 1;
    visited[i] = true;
    for(int& a : adj[i]) {
        if(!visited[a]) sz += dfs(a);
    }
    return sz;
};
```







##  思考问题的启发

###  求子序列长度问题---可以转化成子串长度问题

这有特定的场景要求，一般得先看看给出的数据是否有排序的限定，如果排序是不会改变答案的情况下那么求子序列长度的问题就可以通过排序转化成子串长度问题



###  正难则反

打一个比方，假如题干中要求的是...的最小次数、长度之类的，从反面思考就可以想成求出最长的符合条件的次数，然后用整体减去这个最长的一面，得到的答案就是这个最短的一面了





##  常见错误总结

运算优先级：与运算要比或运算的优先级高

写函数的时候，或者传入数组的时候最好加上引用，今天也是遇到了一个因为没有为数组加上引用而导致爆内存的问题了，在调用函数的时候如果参数是数组，你不写引用的话那么会copy一份那个数组，所以这会耗费一定的空间。