#  算法技巧及模板总结

##  二分查找

以34.在排序数组中查找元素的第一个和最后一个位置经典题目为例，这的`lower_bound()`函数是用来求第一个大于等于target的下标，这一个函数其实能解决大部分问题，主要有大于等于、大于、小于、小于等于，但是都能够通过这一个函数转化过来

**左闭右闭**

```cpp
//左闭右闭写法 [l, r]
int lower_bound1(vector<int>& nums, int target) {
    int l = 0, r = nums.size()-1;
    //区间没有元素的状态是l>r 那么上一个状态(l<=r)就是循环条件
    while(l <= r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid+1;
        else r = mid-1;
    }
    return l;
}
```



**左闭右开**

```cpp
//左闭右开写法 [l, r)
int lower_bound2(vector<int>& nums, int target) {
    int l = 0, r = nums.size();
    //区间没有元素的状态是l==r 那么上一个状态(l<r)就是循环条件
    while(l < r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid+1;
        else r = mid;   //哪边是开区间，那边就不需要1
    }
    return l;   //return r也行
}
```



**左开右开**

```cpp
//左开右开写法 (l, r)
int lower_bound3(vector<int>& nums, int target) {
    int l = -1, r = nums.size();
    //区间没有元素的状态是l+1==r 那么上一个状态(l+1<r)就是循环条件
    while(l+1 < r) {
        int mid = l+(r-l)/2;
        if(nums[mid] < target) l = mid;
        else r = mid;   //哪边是开区间，那边就不需要1
    }
    return l+1; //return r也行
}
```

通过这几种写法的特点，我总结了几个规律：

1、确定区间，三种区间的表达方式
2、循环条件的判断：先想好区间没有元素的状态 那么上一个状态就为循环条件，只改运算符即可
3、防止溢出`mid = l+(r-l)/2`
4、哪边是开区间哪边就不能加一
5、第一个if语句干脆全都写成`if(nums[mid] < target) l = ...`省略号处更具区间开闭情况来判断是否加一
6、最后返回的下标，看循环不变量





##  滑动窗口

###  定长滑动窗口

这种一般题干中会给出滑动窗口的长度k，然后让你求出所有这些长度的滑动窗口中的最大、最小、子数组数目。最大或者最小可能是平均值、和、距离值等等，一般这种定长滑动窗口相对简单，如果想出来的是一个n^2的复杂度的方法肯定是不能ac这一题的，滑动窗口的复杂度是O(n)的，总结的模板大致分为三个步骤：入、维护答案、出。通常滑动窗口类型的题目需要借助哈希表来达到`元素相同个数`，`元素不同个数`这种条件。

```cpp
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        long long ans = 0, sum = 0;
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            cnt[nums[i]]++;	//入
            if(i < k-1) continue;	//没有达到窗口大小直接跳过后面的步骤
            if(cnt.size() == k) ans = max(ans, sum);	//维护答案
            int out = nums[i-k+1];
            sum -= out;
            if(--cnt[out] == 0) cnt.erase(out);	//出
        }
        return ans;
    }
};
```



###  不定长滑动窗口

这种类型的考法就相对来说比较多了，主要分为三类： 求最长子数组，求最短子数组，以及求子数组个数 ，然后经过这一次的周赛(9.29)，求子数组个数又可以细分成：越长越合法(ans+=l)、越短越合法(ans+=r-l+1)、恰好型滑动窗口。对于恰好型滑动窗口就可以把问题转化成两个至多或者两个至少的问题，如果转化成两个至少的问题，那么恰好k就可以表示成 `f(k) - f(k + 1) `，如果转化成两个至多的问题，那么恰好k就可以表示成`f(k)-f(k-1)`





##  思考问题的启发

###  求子序列长度问题---可以转化成子串长度问题

这有特定的场景要求，一般得先看看给出的数据是否有排序的限定，如果排序是不会改变答案的情况下那么求子序列长度的问题就可以通过排序转化成子串长度问题



###  正难则反

打一个比方，假如题干中要求的是...的最小次数、长度之类的，从反面思考就可以想成求出最长的符合条件的次数，然后用整体减去这个最长的一面，得到的答案就是这个最短的一面了





##  常见错误总结

运算优先级：与运算要比或运算的优先级高