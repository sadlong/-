#  9月刷题笔记

##  990.等式方程的可满足性(并查集)

```cpp
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        vector<int> uf(26);
        iota(uf.begin(), uf.end(), 0);
        auto find = [&] (auto&& find, int x) -> int {
            if(uf[x] != x) uf[x] = find(find, uf[x]);
            return uf[x];
        };

        for(string eq : equations) {
            if(eq[1] == '=') {
                uf[find(find, eq[0]-'a')] = find(find, eq[3]-'a');
            }
        }

        for(string eq : equations) {
            if(eq[1] == '!') {
                int fa1 = find(find, eq[0]-'a');
                int fa2 = find(find, eq[3]-'a');
                if(fa1 == fa2) return false;
            }
        }
        return true;
    }
};
```

并查集模板好像都是两三个月前写的了，确实想不起来了，但是还是有一点点的回忆，照着笔记的模板写，再加上题解的解题思路也是写出了和灵神风格的代码了。解题思路是遍历equations两遍，分别是=和!，=用来将元素合并，!用来判断答案。



##  200.岛屿数量(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        function<void(int, int)> dfs = [&] (int i, int j) {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[i].size() || grid[i][j] == '0') return;
            grid[i][j] = '0';
            dfs(i+1, j);
            dfs(i, j+1);
            dfs(i-1, j);
            dfs(i, j-1);
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    ans++;
                    dfs(i, j);
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    var dfs func(i, j int) //相当于少一个等号 多一个var
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == '0' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i, j+1)
        dfs(i-1, j)
        dfs(i, j-1)
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int ans = 0;
        deque<pair<int, int>> q;    //保存grid[i][j] == '1'的下标
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    q.push_back({i, j});
                    grid[i][j] = '0';
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop_front();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < grid.size() && ty >= 0 && ty < grid[0].size() && grid[tx][ty] == '1') {
                                q.push_back({tx, ty});
                                grid[tx][ty] = '0';
                            }
                        }
                    }
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                q = append(q, [2]int{i, j})
                val = '0'
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k := 0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < len(grid) && ty >= 0 && ty < len(grid[0]) && grid[tx][ty] == '1' {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = '0'
                        }
                    }
                }
                ans++;
            }
        }
    }
    return ans
}
```

二刷的题目，结果还是要看笔记才能做出来，但是起码好在看了笔记还是能写出正确答案差不多的样子，



##  695.岛屿的最大面积(bfs, dfs)

dfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return 0;
            grid[i][j] = 0; //标记已访问
            int u = dfs(i+1, j), r = dfs(i, j+1), d = dfs(i-1, j), l = dfs(i, j-1);
            return u+r+d+l+1;
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == 1) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
            return 0;
        }
        grid[i][j] = 0
        u, l, d, r := dfs(i+1, j), dfs(i, j-1), dfs(i-1, j), dfs(i, j+1)
        return u+l+d+r+1
    }

    ans := 0
    for i, row := range grid {
        for j, x := range row {
            if x == 1 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```

这个dfs想不出来的原因啊，我感觉是不会分析`子问题`，子问题分析不出来就导致了不知道如何写返回值，最后开始我想写的是u=dfs(i+1,j)+1，r=dfs(i,j+1)+1以此类推，最后返回u+r+d+l，这样答案是不正确的，答案中`return u+r+d+l+1;`指的就是当前位置，这样才不会重复计算。写的过程中还有一个错误，就是边界条件的判断上，`i >= grid.size() || j >= grid[0].size()`一定要有等于号，不然会导致grid[i] [j]下标越界



bfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int n = grid.size(), m = grid[0].size();
        queue<pair<int, int>> q;
        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                int cnt = 0;
                if(grid[i][j] == 1) {
                    q.push({i, j});
                    cnt++;
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1) {
                                q.push({tx, ty});
                                grid[tx][ty] = 0;
                                cnt++;
                            }
                        }
                    }
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    n, m := len(grid), len(grid[0])
    for i, row := range grid {
        for j, val := range row {
            cnt := 0
            if val == 1 {
                q = append(q, [2]int{i, j})
                grid[i][j] = 0
                cnt++
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k :=  0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1 {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = 0
                            cnt++
                        } 
                    }
                }
            }
            ans = max(ans, cnt)
        }
    }
    return ans
}
```





##  2024.考试的最大困扰度(滑动窗口)

```cpp
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k) {
        int ans = 0, left = 0;
        int cnt[2]{};
        for(int right = 0; right < answerKey.size(); right++) {
            cnt[answerKey[right] >> 1 & 1]++;
            while(cnt[0] > k && cnt[1] > k) cnt[answerKey[left++] >> 1 & 1]--;
            ans = max(ans, right-left+1);
        }
        return ans;
    }
};
```



```go
func maxConsecutiveAnswers(answerKey string, k int) int {
    ans, left := 0, 0
    cnt := [2]int{}
    for right, ch := range answerKey {
        cnt[ch >> 1 & 1]++
        for cnt[0] > k && cnt[1] > k {
            cnt[answerKey[left] >> 1 & 1]--
            left++
        }
        ans = max(ans, right-left+1)
    }
    return ans
}
```

好久没做过滑动窗口的题目了，这个呢好像和之前做过的有点不一样，这个题的意思其实是让你求出这个滑动窗口的窗口最大值，而以前做过的题目呢都类似于给出了窗口的大小，然后让你求什么什么的。但是总的来说其实好像意思都是一样的，在右端移动的过程中因为题干中的某些限定条件，从而导致左端点也要跟着移动



##  2860.让所有学生保持开心的分组方法数(排序)

```cpp
class Solution {
public:
    int countWays(vector<int>& nums) {
        ranges::sort(nums);
        int ans = nums[0] > 0;
        for(int i = 1; i < nums.size(); i++) {
            ans +=  nums[i-1] < i && i < nums[i];
        }
        return ans+1;
    }
};
```



```go
func countWays(nums []int) ( ans int) {
    sort.Ints(nums)
    if nums[0] > 0 {
        ans = 1
    }

    for i := 1; i < len(nums)-1; i++ {
        if nums[i-1] < i && i < nums[i] {
            ans++
        }
    }
    return ans+1
}
```

灵神的话确实说的好，遇事不决先排序，当所求的答案和顺序没有关系的时候可以先无脑排序一下，这一题就是如此，给出的条件就是和大小相关，所以排序之后可能就会让问题变得简单。然后就是可以枚举选的人数，得出以下关系式：满足`nums[i-1] < i && i < nums[i]`就让ans方案数累加



##  面试题16.19.水域大小(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;

        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= land.size() || j >= land[0].size() || land[i][j] != 0) return 0;
            land[i][j] = 1;
            int res = 1;
            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(dx == 0 && dy == 0) continue;
                    res += dfs(i+dx, j+dy);
                }
            }
            return res;
        };

        for(int i = 0; i < land.size(); i++) {
            for(int j = 0; j < land[0].size(); j++) {
                if(land[i][j] == 0) {
                    ans.push_back(dfs(i, j));
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```



```go
func pondSizes(land [][]int) []int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(land) || j >= len(land[0]) || land[i][j] != 0 {
            return 0
        }
        land[i][j] = 1
        res := 1
        for dx := -1; dx <= 1; dx++ {
            for dy := -1; dy <= 1; dy++{
                if dx == 0 && dy == 0 {
                    continue
                }
                res += dfs(i+dx, j+dy)
            }
        }
        return res
    }

    ans := []int{}
    for i, row := range land {
        for j, val := range row {
            if val == 0 {
                ans = append(ans, dfs(i, j))
            }
        }
    }
    sort.Ints(ans)
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;
        queue<pair<int, int>> q;
        for(int i = 0; i < land.size(); i++) {
            for(int j = 0; j < land[0].size(); j++) {
                if(land[i][j] == 0) {
                    q.push({i, j});
                    land[i][j] = 1;
                    int cnt = 1;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int dx = -1; dx <= 1; dx++) {
                            for(int dy = -1; dy <= 1; dy++) {
                                if(dx == 0 && dy == 0) continue;
                                int tx = t.first+dx, ty = t.second+dy;
                                if(tx >= 0 && tx < land.size() && ty >= 0 && ty < land[0].size() && land[tx][ty] == 0) {
                                    q.push({tx, ty});
                                    cnt++;
                                    land[tx][ty] = 1;
                                }
                            }
                        }
                    }
                    ans.push_back(cnt);
                }
            }
        }
        ranges::sort(ans);
        return ans;
    }
};
```

这一题与之前不同的地方就在于对角线上也需要搜索，所以就变成了8个方向的dfs和bfs，这样可以直接用循环体来表示，这样更简洁

```cpp
int res = 1;
//枚举8个方向，(0,0)坐标除外，虽然不会超时，主要是没必要，因为已经标记过已访问
for(int dx = -1; dx <= 1; dx++) {
    for(int dy = -1; dy <= 1; dy++) {
        if(dx == 0 && dy == 0) continue;
        res += dfs(i+dx, j+dy);
    }
}
```





##  463.岛屿的周长(dfs)

```cpp
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        function<int(int, int)> dfs = [&](int i, int j) ->int {
            if(i < 0 || j < 0 || i >= n || j >= m) return 1;
            if(grid[i][j] == -1) return 0;
            else if(grid[i][j] == 0) return 1; 
            grid[i][j] = -1;	//已访问位
            int u = dfs(i+1, j), l = dfs(i, j-1), d = dfs(i-1, j), r = dfs(i, j+1);
            return u+l+d+r;
        };
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 1) return dfs(i, j);
            }
        }
        return 4;
    }
};
```

观察这个题的意思，其实和前面做的岛屿题目大致是一个意思，获取答案的方式不同而已，当下标越绝或者访问道的是水的时候就返回1，而当访问到陆地的时候返回0



##  2658.网格中鱼的最大数目(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        function<int(int, int)> dfs = [&](int i, int j) ->int {
            if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0) return 0;
            int res = grid[i][j];
            grid[i][j] = 0;
            int u = dfs(i-1, j), l = dfs(i, j-1), d = dfs(i+1, j), r = dfs(i, j+1);
            return u+l+d+r+res;
        };

        int ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] > 0) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func findMaxFish(grid [][]int) int {
    n, m := len(grid), len(grid[0])
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0 {
            return 0
        }
        res := grid[i][j]
        grid[i][j] = 0
        u, l, d, r := dfs(i-1, j), dfs(i, j-1), dfs(i+1, j), dfs(i, j+1)
        return u+l+d+r+res
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val > 0 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int x[4] = {-1, 0, 1, 0};
        int y[4] = {0, -1, 0, 1};
        queue<pair<int, int>> q;
        int ans = 0;
        int n = grid.size(), m = grid[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] > 0) {
                    q.push({i, j});
                    int cnt = grid[i][j];
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int i = 0; i < 4; i++) {
                            int tx = t.first+x[i], ty = t.second+y[i];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] > 0) {
                                q.push({tx, ty});
                                cnt += grid[tx][ty];
                                grid[tx][ty] = 0;
                            }
                        }
                    }
                    ans = max(ans, cnt);
                }
            }
        }
        return ans;
    }
};
```





##  1034.边界着色(dfs)

```cpp
class Solution {
public:
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {
        int n = grid.size(), m = grid[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};  //代表上左下右
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        function<void(int, int, int)> dfs = [&](int i, int j, int val) {
            vis[i][j] = true;
            for(auto dir : dirs) {
                int dx = i+dir[0], dy = j+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m) {
                    if(vis[dx][dy] == true) continue;
                    //把这个理解成递归进入的入口
                    if(grid[dx][dy] == val) dfs(dx, dy, val);
                    else grid[i][j] = color;	//不是grid[dx][dy]=color
                } else {
                    grid[i][j] = color;
                }
            }
        };
        dfs(row, col, grid[row][col]);
        return grid;
    }
};
```

昨天感觉学的还不错，今天就来了个当头一棒，写的代码又臭又长，还不能过全部样例，这一个题解还出现了新的东西，就是表示这四个方向，在这里就必须要这样枚举四个方向了，而不能单纯的dfs(i+1,j)这样了，相比以前这一题的限定就更多了，所以只能枚举四个方向单独进行判断



##  1020.飞地的数量(dfs)

```cpp
class Solution {
public:
    int numEnclaves(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        int ans = 0;
        function<void(int, int)> dfs = [&](int i, int j) {
            grid[i][j] = 0;
            ans++;
            for(auto dir : dirs) {
                int dx = i+dir[0], dy = j+dir[1];
                if(dx < 0 || dy < 0 || dx >= n || dy >= m || grid[dx][dy] == 0) continue;
                dfs(dx, dy);
            }
            return;
        };

        for(int i = 0; i < n; i++) {
            if(grid[i][0] == 1) dfs(i, 0);
            if(grid[i][m-1] == 1) dfs(i, m-1);
        }
        for(int j = 0; j < m; j++) {
            if(grid[0][j] == 1) dfs(0, j);
            if(grid[n-1][j] == 1) dfs(n-1, j);
        }
        ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 1) dfs(i, j);
            }
        }
        return ans;
    }
};
```

主要问题在于不知道怎么解决我真的服了。。。还是多练习吧，主要思路是先将上下左右边界遍历一遍，当遇到1的时候就将所在连通分量全部变为0，这样就不会算在计数里面了，由于dfs函数体内对ans进行了修改，所以最后在找无法离开的陆地格子的时候就先要将ans清0即可



##  2684.矩阵中移动的最大次数(dfs)

```cpp
class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        int ans = 0, n = grid.size(), m = grid[0].size();
        int dirs[][2] = {{-1, 1}, {0, 1}, {1, 1}};
        function<void(int, int)> dfs = [&](int i, int j) {
            ans = max(ans, j);  //更新答案 这里的答案就是最远的列下标
            if(ans == m-1) return;
            for(auto dir : dirs) {
                int dx = i+dir[0], dy = j+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m && grid[i][j] < grid[dx][dy]) dfs(dx, dy);
            }
            grid[i][j] = 0;
        };
        for(int i = 0; i < n; i++) dfs(i, 0);
        return ans;
    }
};
```

好烦啊，怎么就是写不出来，就是搞不清楚什么时候dfs要有返回值，什么时候可以不需要有返回值





##  1254.统计封闭岛屿的数目(dfs)

```cpp
class Solution {
public:
    int closedIsland(vector<vector<int>>& grid) {
        int ans = 0, n = grid.size(), m = grid[0].size();
        auto dfs = [&](auto&& dfs, int i, int j) {
            if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1) return;
            grid[i][j] = 1;
            dfs(dfs, i-1, j);
            dfs(dfs, i, j-1);
            dfs(dfs, i+1, j);
            dfs(dfs, i, j+1);
        };

        for(int i = 0; i < n; i++) {
            int step = i == 0 || i == n-1 ? 1 : m-1;
            for(int j = 0; j < m; j += step) {
                dfs(dfs, i, j);
            }
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 0) {
                    ans++;
                    dfs(dfs, i, j);
                }
            }
        }
        return ans;
    }
};
```


```go
func closedIsland(grid [][]int) int {
    ans, n, m := 0, len(grid), len(grid[0])
    var dfs func(i, j int)
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1 {
            return
        }
        grid[i][j] = 1
        dfs(i-1, j)
        dfs(i, j-1)
        dfs(i+1, j)
        dfs(i, j+1)
    }

    for i := range grid {
        step := 1
        if i > 0 && i < n-1 {
            step = m-1
        }
        for j := 0; j < m; j += step {
            dfs(i, j)
        }
    }

    for i, row := range grid {
        for j, val := range row {
            if val == 0 {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```

主要难点在于用什么算法能够实现题中的意思，这一题用的解法是：考虑到在网格边界的土地一定不是封闭岛屿，所以先dfs边界上的0，将他们变为1，然后再遍历非边界的0的联通分量，这个联通分量一定是符合封闭岛屿的。



##  130.被围绕的区域(dfs)

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int n = board.size(), m = board[0].size();
        if(n == 0) return;
        auto dfs = [&](auto&& dfs, int i, int j) {
            if(i < 0 || j < 0 || i >= n || j >= m || board[i][j] != 'O') return;
            board[i][j] = 'A';
            dfs(dfs, i-1, j);
            dfs(dfs, i, j-1);
            dfs(dfs, i+1, j);
            dfs(dfs, i, j+1);
        };

        for(int i = 0; i < n; i++) {
            int step = i == 0 || i == n-1 ? 1 : m-1;
            for(int j = 0; j < m; j += step) {
                dfs(dfs, i, j);
            }
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(board[i][j] == 'A') board[i][j] = 'O';
                else if(board[i][j] == 'O') board[i][j] = 'X';
            }
        }
        return;
    }
};
```



```go
func solve(board [][]byte)  {
    var dfs func(i, j int)
    n, m := len(board), len(board[0])
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= n || j >= m || board[i][j] != 'O' {
            return
        }
        board[i][j] = 'A';
        dfs(i-1, j)
        dfs(i, j-1)
        dfs(i+1, j)
        dfs(i, j+1)
    }

    for i := range board {
        step := 1
        if i > 0 && i < n-1 {
            step = m-1
        }
        for j := 0; j < m; j += step {
            dfs(i, j)
        }
    }

    for i, row := range board {
        for j, val := range row {
            if val == 'A' {
                board[i][j] = 'O'
            } else if val == 'O' {
                board[i][j] = 'X'
            }
        }
    }
}
```

这个题和上一题还是很像的，也是想到了，就是先dfs边界条件，但是但是，感觉思维被上个题完全带走了，就想着dfs了边界后还要dfs里面的，其实并不需要啊，只需要遍历一遍这个board就行了。。。然后将相应元素替换掉就行了，啊啊啊啊啊感觉智商被践踏了。还有就是这个大写的O和0，我真的服了。。。





##  542.01矩阵(bfs)

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        queue<pair<int, int>> q;
        int n = mat.size(), m = mat[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(mat[i][j] == 0) {
                    vis[i][j] = true;
                    q.push({i, j});
                }
            }
        }

        vector<vector<int>> dist(n, vector<int>(m, 0));
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t.first+dir[0], dy = t.second+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m && !vis[dx][dy]) {
                    dist[dx][dy] = dist[t.first][t.second]+1;
                    q.push({dx, dy});
                    vis[dx][dy] = true;
                }
            }
        }
        return dist;
    }
};
```

很明显了，这一题题干就是给出的求对应元素到0的最近距离，自己想好像真的不好想，主要是这个多元素困扰到了，这里题解给的方法是将所有`0`看成一个整体，也就是所说的超级0，前面两层for循环就是做的这个事情，与以往不同的是，这里需要定义一个vis数组来表示是否访问过，以前岛屿那种题型就是在数组原地修改来达到已经访问的意思，这里需要额外定义一个空间来记录，当然对于岛屿题目也可以自己定义一个vis数组，只不过就是内存消耗大了一点点，其余其实没有什么问题



##  994.腐烂的橘子(bfs)

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        vector<vector<int>> dist(n, vector<int>(m, 0));
        queue<pair<int, int>> q;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 2) {
                    q.push({i, j});
                    vis[i][j] = true;
                }
            }
        }

        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t.first+dir[0], dy = t.second+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m && grid[dx][dy] == 1 && !vis[dx][dy]) {
                    vis[dx][dy] = true;
                    dist[dx][dy] = dist[t.first][t.second]+1;
                    q.push({dx, dy});
                }
            }
        }

        int ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(!vis[i][j] && grid[i][j] == 1) return  -1;
                ans = max(ans, dist[i][j]);
            }
        }
        return ans;
    }
};
```

自己独立顺利ac了，主要是学的上一题的01矩阵的官解方法，虽然代码冗长了一点，但是整体写的思路还是很流畅的，现在发现了bfs相对dfs要好写一点，虽然长是长了点，但是这种思路畅通的感觉就是爽一点





##  2684.矩阵中移动的最大次数(bfs)

```cpp
class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> vis(m, -1), q(m);
        iota(q.begin(), q.end(), 0);
        for(int j = 0; j < n-1; j++) {
            vector<int> nxt;
            for(auto i : q) {
                for(int k = max(i-1, 0); k < min(m, i+2); k++) {
                    if(vis[k] != j && grid[k][j+1] > grid[i][j]) {
                        vis[k] = j;
                        nxt.push_back(k);
                    }
                }
            }
            if(nxt.empty()) return j;
            q = move(nxt);
        }
        return n-1;
    }
};
```

这个是用的双数组的写法，和之前的dfs一样都有点看不懂，主要是灵神的方法和以往不一样，又是先遍历列，初始化都是第一列的元素，感觉遍历方式只要打破常规就感觉不是很好理解了



##  1926.迷宫中离入口最近的出口(bfs)

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        queue<array<int, 3>> q;
        q.push({entrance[0], entrance[1], 0});
        maze[entrance[0]][entrance[1]] = '+';
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t[0]+dir[0], dy = t[1]+dir[1];
                if(dx >= 0 && dx < m && dy >= 0 && dy < n && maze[dx][dy] == '.') {
                    if(dx == 0 || dy == 0 || dx == m-1 || dy == n-1) return t[2]+1;
                    q.push({dx, dy, t[2]+1});
                    maze[dx][dy] = '+';
                }
            }
        }
        return -1;
    }
};
```

属于是给前两题整魔怔了，我还以刚刚的多源bfs来写，写道一半后发现这个起始点不就只有一个吗？啊？那我为什么要写多源的bfs啊，感觉这个题要比多源的bfs要简单一点，就是直接从起始点出发去找最近的一个边界，想是想到了，但是怎么维护这个补数就困扰到我了，所以在这个地方我不知道怎么写，看了官解之后原来就就是将每一个入队的元素多维护一个距离，这就是为什么队列q要定义成`queue<array<int, 3>> q;`



```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        queue<pair<int, int>> q;
        q.push({entrance[0], entrance[1]});
        maze[entrance[0]][entrance[1]] = '+';
        int ans = 0;
        while(!q.empty()) {
            int sz = q.size();
            //一层一层的遍历
            for(int k = 0; k < sz; k++) {
                auto t = q.front();
                q.pop();
                for(auto dir : dirs) {
                    int dx = t.first+dir[0], dy = t.second+dir[1];
                    if(dx >= 0 && dx < m && dy >= 0 && dy < n) {
                        if(maze[dx][dy] == '.') {
                            q.push({dx, dy});
                            maze[dx][dy] = '+';
                        }
                    } else if(t.first != entrance[0] || t.second != entrance[1]) {
                        return ans;
                    }
                }
            }

            ans++;
        }
        return -1;
    }
};
```

这是题解区中的另外一个bfs，这个也挺妙的，就是相当于以那个出发点做出一个层序遍历，最后返回的那个值就是层序遍历的最小层数，然后我就按照它那样改，改到后面发现怎么跑都不对，然后仔细发现原来是还要套一层for循环，这个for循环也挺好理解，就是一层一层的遍历这个队列q，然后每次遍历一遍就将ans++，这也是个好方法啊！







##  总结归纳

###  并查集模板

```cpp
vector<int> uf(n);

//init
iota(uf.begin(), uf.end(), 0);

//find
auto find = [&] (auto&& find, int x) -> int {
    if(uf[x] != x) uf[x] = find(find, uf[x]);
    return uf[x];
};

//union
for(auto ... : ...) {
    if(...) {
        uf[find(find, ...)] = find(find, ...);
    }
}
```



###  网格dfs、bfs

大多数情况下两种方法都能解决，dfs代码看上去相对简洁一点，但是理解起来比较费劲，着重考虑子问题是否分析正确。在遇到这类问题的时候容易出现的几个错误：1、边界出错导致数组越界。2、没有更新已访问节点导致死循环。3、注意题干中所给的网格大小，通常在1000以内还是能够解决的不会超时

什么时候用dfs，什么时候用bfs呢？这两种方法其实在大部分情况看来两种都是能用用的方法，主流来说连通块问题用dfs，求最短路径用bfs





###  滑动窗口模板

**未知窗口大小求窗口大小**

```cpp
int solve(string answerKey) {
    int ans = 0, left = 0;
    int cnt[2]{};
    for(int right = 0; right < answerKey.size(); right++) {
        cnt[answerKey[right] >> 1 & 1]++;
        while(...) cnt[answerKey[left++] >> 1 & 1]--;	//可能维护计数、和之类的东西
        ans = max(ans, right-left+1);//求滑动窗口的大小
    }
    return ans;
}
```



**已知窗口大小**---步骤分为入、出、记录数据

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> q;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++)
    {
        //入
        while(!q.empty() && nums[i] >= nums[q.back()]) q.pop_back();
        q.push_back(i);

        //出
        if(i-q.front() >= k) q.pop_front();

        //记录数据
        if(i >= k-1) res.push_back(nums[q.front()]);
    }
    return res;
}
```





###  遇事不决先排序

当题中给出某些大小关系才能给出答案的字眼中，并且答案和顺序无关的时候可以先排序看看问题能不能变得简便很多