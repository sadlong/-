#  9月刷题笔记

##  990.等式方程的可满足性(并查集)

```cpp
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        vector<int> uf(26);
        iota(uf.begin(), uf.end(), 0);
        auto find = [&] (auto&& find, int x) -> int {
            if(uf[x] != x) uf[x] = find(find, uf[x]);
            return uf[x];
        };

        for(string eq : equations) {
            if(eq[1] == '=') {
                uf[find(find, eq[0]-'a')] = find(find, eq[3]-'a');
            }
        }

        for(string eq : equations) {
            if(eq[1] == '!') {
                int fa1 = find(find, eq[0]-'a');
                int fa2 = find(find, eq[3]-'a');
                if(fa1 == fa2) return false;
            }
        }
        return true;
    }
};
```

并查集模板好像都是两三个月前写的了，确实想不起来了，但是还是有一点点的回忆，照着笔记的模板写，再加上题解的解题思路也是写出了和灵神风格的代码了。解题思路是遍历equations两遍，分别是=和!，=用来将元素合并，!用来判断答案。



##  200.岛屿数量(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        function<void(int, int)> dfs = [&] (int i, int j) {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[i].size() || grid[i][j] == '0') return;
            grid[i][j] = '0';
            dfs(i+1, j);
            dfs(i, j+1);
            dfs(i-1, j);
            dfs(i, j-1);
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    ans++;
                    dfs(i, j);
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    var dfs func(i, j int) //相当于少一个等号 多一个var
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == '0' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i, j+1)
        dfs(i-1, j)
        dfs(i, j-1)
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int ans = 0;
        deque<pair<int, int>> q;    //保存grid[i][j] == '1'的下标
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    q.push_back({i, j});
                    grid[i][j] = '0';
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop_front();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < grid.size() && ty >= 0 && ty < grid[0].size() && grid[tx][ty] == '1') {
                                q.push_back({tx, ty});
                                grid[tx][ty] = '0';
                            }
                        }
                    }
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                q = append(q, [2]int{i, j})
                val = '0'
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k := 0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < len(grid) && ty >= 0 && ty < len(grid[0]) && grid[tx][ty] == '1' {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = '0'
                        }
                    }
                }
                ans++;
            }
        }
    }
    return ans
}
```

二刷的题目，结果还是要看笔记才能做出来，但是起码好在看了笔记还是能写出正确答案差不多的样子，



##  695.岛屿的最大面积(bfs, dfs)

dfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return 0;
            grid[i][j] = 0; //标记已访问
            int u = dfs(i+1, j), r = dfs(i, j+1), d = dfs(i-1, j), l = dfs(i, j-1);
            return u+r+d+l+1;
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == 1) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
            return 0;
        }
        grid[i][j] = 0
        u, l, d, r := dfs(i+1, j), dfs(i, j-1), dfs(i-1, j), dfs(i, j+1)
        return u+l+d+r+1
    }

    ans := 0
    for i, row := range grid {
        for j, x := range row {
            if x == 1 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```

这个dfs想不出来的原因啊，我感觉是不会分析`子问题`，子问题分析不出来就导致了不知道如何写返回值，最后开始我想写的是u=dfs(i+1,j)+1，r=dfs(i,j+1)+1以此类推，最后返回u+r+d+l，这样答案是不正确的，答案中`return u+r+d+l+1;`指的就是当前位置，这样才不会重复计算。写的过程中还有一个错误，就是边界条件的判断上，`i >= grid.size() || j >= grid[0].size()`一定要有等于号，不然会导致grid[i] [j]下标越界



bfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int n = grid.size(), m = grid[0].size();
        queue<pair<int, int>> q;
        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                int cnt = 0;
                if(grid[i][j] == 1) {
                    q.push({i, j});
                    cnt++;
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1) {
                                q.push({tx, ty});
                                grid[tx][ty] = 0;
                                cnt++;
                            }
                        }
                    }
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    n, m := len(grid), len(grid[0])
    for i, row := range grid {
        for j, val := range row {
            cnt := 0
            if val == 1 {
                q = append(q, [2]int{i, j})
                grid[i][j] = 0
                cnt++
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k :=  0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1 {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = 0
                            cnt++
                        } 
                    }
                }
            }
            ans = max(ans, cnt)
        }
    }
    return ans
}
```





##  2024.考试的最大困扰度(滑动窗口)

```cpp
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k) {
        int ans = 0, left = 0;
        int cnt[2]{};
        for(int right = 0; right < answerKey.size(); right++) {
            cnt[answerKey[right] >> 1 & 1]++;
            while(cnt[0] > k && cnt[1] > k) cnt[answerKey[left++] >> 1 & 1]--;
            ans = max(ans, right-left+1);
        }
        return ans;
    }
};
```



```go
func maxConsecutiveAnswers(answerKey string, k int) int {
    ans, left := 0, 0
    cnt := [2]int{}
    for right, ch := range answerKey {
        cnt[ch >> 1 & 1]++
        for cnt[0] > k && cnt[1] > k {
            cnt[answerKey[left] >> 1 & 1]--
            left++
        }
        ans = max(ans, right-left+1)
    }
    return ans
}
```

好久没做过滑动窗口的题目了，这个呢好像和之前做过的有点不一样，这个题的意思其实是让你求出这个滑动窗口的窗口最大值，而以前做过的题目呢都类似于给出了窗口的大小，然后让你求什么什么的。但是总的来说其实好像意思都是一样的，在右端移动的过程中因为题干中的某些限定条件，从而导致左端点也要跟着移动



##  2860.让所有学生保持开心的分组方法数(排序)

```cpp
class Solution {
public:
    int countWays(vector<int>& nums) {
        ranges::sort(nums);
        int ans = nums[0] > 0;
        for(int i = 1; i < nums.size(); i++) {
            ans +=  nums[i-1] < i && i < nums[i];
        }
        return ans+1;
    }
};
```



```go
func countWays(nums []int) ( ans int) {
    sort.Ints(nums)
    if nums[0] > 0 {
        ans = 1
    }

    for i := 1; i < len(nums)-1; i++ {
        if nums[i-1] < i && i < nums[i] {
            ans++
        }
    }
    return ans+1
}
```

灵神的话确实说的好，遇事不决先排序，当所求的答案和顺序没有关系的时候可以先无脑排序一下，这一题就是如此，给出的条件就是和大小相关，所以排序之后可能就会让问题变得简单。然后就是可以枚举选的人数，得出以下关系式：满足`nums[i-1] < i && i < nums[i]`就让ans方案数累加



##  面试题16.19.水域大小(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;

        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= land.size() || j >= land[0].size() || land[i][j] != 0) return 0;
            land[i][j] = 1;
            int res = 1;
            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(dx == 0 && dy == 0) continue;
                    res += dfs(i+dx, j+dy);
                }
            }
            return res;
        };

        for(int i = 0; i < land.size(); i++) {
            for(int j = 0; j < land[0].size(); j++) {
                if(land[i][j] == 0) {
                    ans.push_back(dfs(i, j));
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```



```go
func pondSizes(land [][]int) []int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(land) || j >= len(land[0]) || land[i][j] != 0 {
            return 0
        }
        land[i][j] = 1
        res := 1
        for dx := -1; dx <= 1; dx++ {
            for dy := -1; dy <= 1; dy++{
                if dx == 0 && dy == 0 {
                    continue
                }
                res += dfs(i+dx, j+dy)
            }
        }
        return res
    }

    ans := []int{}
    for i, row := range land {
        for j, val := range row {
            if val == 0 {
                ans = append(ans, dfs(i, j))
            }
        }
    }
    sort.Ints(ans)
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;
        queue<pair<int, int>> q;
        for(int i = 0; i < land.size(); i++) {
            for(int j = 0; j < land[0].size(); j++) {
                if(land[i][j] == 0) {
                    q.push({i, j});
                    land[i][j] = 1;
                    int cnt = 1;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int dx = -1; dx <= 1; dx++) {
                            for(int dy = -1; dy <= 1; dy++) {
                                if(dx == 0 && dy == 0) continue;
                                int tx = t.first+dx, ty = t.second+dy;
                                if(tx >= 0 && tx < land.size() && ty >= 0 && ty < land[0].size() && land[tx][ty] == 0) {
                                    q.push({tx, ty});
                                    cnt++;
                                    land[tx][ty] = 1;
                                }
                            }
                        }
                    }
                    ans.push_back(cnt);
                }
            }
        }
        ranges::sort(ans);
        return ans;
    }
};
```

这一题与之前不同的地方就在于对角线上也需要搜索，所以就变成了8个方向的dfs和bfs，这样可以直接用循环体来表示，这样更简洁

```cpp
int res = 1;
//枚举8个方向，(0,0)坐标除外，虽然不会超时，主要是没必要，因为已经标记过已访问
for(int dx = -1; dx <= 1; dx++) {
    for(int dy = -1; dy <= 1; dy++) {
        if(dx == 0 && dy == 0) continue;
        res += dfs(i+dx, j+dy);
    }
}
```





##  463.岛屿的周长(dfs)

```cpp
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        function<int(int, int)> dfs = [&](int i, int j) ->int {
            if(i < 0 || j < 0 || i >= n || j >= m) return 1;
            if(grid[i][j] == -1) return 0;
            else if(grid[i][j] == 0) return 1; 
            grid[i][j] = -1;	//已访问位
            int u = dfs(i+1, j), l = dfs(i, j-1), d = dfs(i-1, j), r = dfs(i, j+1);
            return u+l+d+r;
        };
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 1) return dfs(i, j);
            }
        }
        return 4;
    }
};
```

观察这个题的意思，其实和前面做的岛屿题目大致是一个意思，获取答案的方式不同而已，当下标越绝或者访问道的是水的时候就返回1，而当访问到陆地的时候返回0



##  2658.网格中鱼的最大数目(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        function<int(int, int)> dfs = [&](int i, int j) ->int {
            if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0) return 0;
            int res = grid[i][j];
            grid[i][j] = 0;
            int u = dfs(i-1, j), l = dfs(i, j-1), d = dfs(i+1, j), r = dfs(i, j+1);
            return u+l+d+r+res;
        };

        int ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] > 0) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func findMaxFish(grid [][]int) int {
    n, m := len(grid), len(grid[0])
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0 {
            return 0
        }
        res := grid[i][j]
        grid[i][j] = 0
        u, l, d, r := dfs(i-1, j), dfs(i, j-1), dfs(i+1, j), dfs(i, j+1)
        return u+l+d+r+res
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val > 0 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int x[4] = {-1, 0, 1, 0};
        int y[4] = {0, -1, 0, 1};
        queue<pair<int, int>> q;
        int ans = 0;
        int n = grid.size(), m = grid[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] > 0) {
                    q.push({i, j});
                    int cnt = grid[i][j];
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int i = 0; i < 4; i++) {
                            int tx = t.first+x[i], ty = t.second+y[i];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] > 0) {
                                q.push({tx, ty});
                                cnt += grid[tx][ty];
                                grid[tx][ty] = 0;
                            }
                        }
                    }
                    ans = max(ans, cnt);
                }
            }
        }
        return ans;
    }
};
```













##  总结归纳

###  并查集模板

```cpp
vector<int> uf(n);

//init
iota(uf.begin(), uf.end(), 0);

//find
auto find = [&] (auto&& find, int x) -> int {
    if(uf[x] != x) uf[x] = find(find, uf[x]);
    return uf[x];
};

//union
for(auto ... : ...) {
    if(...) {
        uf[find(find, ...)] = find(find, ...);
    }
}
```



###  网格dfs、bfs

大多数情况下两种方法都能解决，dfs代码看上去相对简洁一点，但是理解起来比较费劲，着重考虑子问题是否分析正确。在遇到这类问题的时候容易出现的几个错误：1、边界出错导致数组越界。2、没有更新已访问节点导致死循环。3、注意题干中所给的网格大小，通常在1000以内还是能够解决的不会超时





###  滑动窗口模板

**未知窗口大小求窗口大小**

```cpp
int solve(string answerKey) {
    int ans = 0, left = 0;
    int cnt[2]{};
    for(int right = 0; right < answerKey.size(); right++) {
        cnt[answerKey[right] >> 1 & 1]++;
        while(...) cnt[answerKey[left++] >> 1 & 1]--;	//可能维护计数、和之类的东西
        ans = max(ans, right-left+1);//求滑动窗口的大小
    }
    return ans;
}
```



**已知窗口大小**---步骤分为入、出、记录数据

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> q;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++)
    {
        //入
        while(!q.empty() && nums[i] >= nums[q.back()]) q.pop_back();
        q.push_back(i);

        //出
        if(i-q.front() >= k) q.pop_front();

        //记录数据
        if(i >= k-1) res.push_back(nums[q.front()]);
    }
    return res;
}
```





###  遇事不决先排序

当题中给出某些大小关系才能给出答案的字眼中，并且答案和顺序无关的时候可以先排序看看问题能不能变得简便很多