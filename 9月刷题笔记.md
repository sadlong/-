#  9月刷题笔记

##  990.等式方程的可满足性(并查集)

```cpp
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        vector<int> uf(26);
        iota(uf.begin(), uf.end(), 0);
        auto find = [&] (auto&& find, int x) -> int {
            if(uf[x] != x) uf[x] = find(find, uf[x]);
            return uf[x];
        };

        for(string eq : equations) {
            if(eq[1] == '=') {
                uf[find(find, eq[0]-'a')] = find(find, eq[3]-'a');
            }
        }

        for(string eq : equations) {
            if(eq[1] == '!') {
                int fa1 = find(find, eq[0]-'a');
                int fa2 = find(find, eq[3]-'a');
                if(fa1 == fa2) return false;
            }
        }
        return true;
    }
};
```

并查集模板好像都是两三个月前写的了，确实想不起来了，但是还是有一点点的回忆，照着笔记的模板写，再加上题解的解题思路也是写出了和灵神风格的代码了。解题思路是遍历equations两遍，分别是=和!，=用来将元素合并，!用来判断答案。



##  200.岛屿数量(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        function<void(int, int)> dfs = [&] (int i, int j) {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[i].size() || grid[i][j] == '0') return;
            grid[i][j] = '0';
            dfs(i+1, j);
            dfs(i, j+1);
            dfs(i-1, j);
            dfs(i, j-1);
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    ans++;
                    dfs(i, j);
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    var dfs func(i, j int) //相当于少一个等号 多一个var
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == '0' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i, j+1)
        dfs(i-1, j)
        dfs(i, j-1)
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int ans = 0;
        deque<pair<int, int>> q;    //保存grid[i][j] == '1'的下标
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    q.push_back({i, j});
                    grid[i][j] = '0';
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop_front();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < grid.size() && ty >= 0 && ty < grid[0].size() && grid[tx][ty] == '1') {
                                q.push_back({tx, ty});
                                grid[tx][ty] = '0';
                            }
                        }
                    }
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                q = append(q, [2]int{i, j})
                val = '0'
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k := 0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < len(grid) && ty >= 0 && ty < len(grid[0]) && grid[tx][ty] == '1' {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = '0'
                        }
                    }
                }
                ans++;
            }
        }
    }
    return ans
}
```

二刷的题目，结果还是要看笔记才能做出来，但是起码好在看了笔记还是能写出正确答案差不多的样子，

111







##  总结归纳

###  并查集模板

```cpp
vector<int> uf(n);

//init
iota(uf.begin(), uf.end(), 0);

//find
auto find = [&] (auto&& find, int x) -> int {
    if(uf[x] != x) uf[x] = find(find, uf[x]);
    return uf[x];
};

//union
for(auto ... : ...) {
    if(...) {
        uf[find(find, ...)] = find(find, ...);
    }
}
```

