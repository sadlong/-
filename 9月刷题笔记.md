#  9月刷题笔记

##  990.等式方程的可满足性(并查集)

```cpp
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        vector<int> uf(26);
        iota(uf.begin(), uf.end(), 0);
        auto find = [&] (auto&& find, int x) -> int {
            if(uf[x] != x) uf[x] = find(find, uf[x]);
            return uf[x];
        };

        for(string eq : equations) {
            if(eq[1] == '=') {
                uf[find(find, eq[0]-'a')] = find(find, eq[3]-'a');
            }
        }

        for(string eq : equations) {
            if(eq[1] == '!') {
                int fa1 = find(find, eq[0]-'a');
                int fa2 = find(find, eq[3]-'a');
                if(fa1 == fa2) return false;
            }
        }
        return true;
    }
};
```

并查集模板好像都是两三个月前写的了，确实想不起来了，但是还是有一点点的回忆，照着笔记的模板写，再加上题解的解题思路也是写出了和灵神风格的代码了。解题思路是遍历equations两遍，分别是=和!，=用来将元素合并，!用来判断答案。



##  200.岛屿数量(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        function<void(int, int)> dfs = [&] (int i, int j) {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[i].size() || grid[i][j] == '0') return;
            grid[i][j] = '0';
            dfs(i+1, j);
            dfs(i, j+1);
            dfs(i-1, j);
            dfs(i, j-1);
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    ans++;
                    dfs(i, j);
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    var dfs func(i, j int) //相当于少一个等号 多一个var
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == '0' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i, j+1)
        dfs(i-1, j)
        dfs(i, j-1)
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int ans = 0;
        deque<pair<int, int>> q;    //保存grid[i][j] == '1'的下标
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    q.push_back({i, j});
                    grid[i][j] = '0';
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop_front();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < grid.size() && ty >= 0 && ty < grid[0].size() && grid[tx][ty] == '1') {
                                q.push_back({tx, ty});
                                grid[tx][ty] = '0';
                            }
                        }
                    }
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                q = append(q, [2]int{i, j})
                val = '0'
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k := 0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < len(grid) && ty >= 0 && ty < len(grid[0]) && grid[tx][ty] == '1' {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = '0'
                        }
                    }
                }
                ans++;
            }
        }
    }
    return ans
}
```

二刷的题目，结果还是要看笔记才能做出来，但是起码好在看了笔记还是能写出正确答案差不多的样子，



##  695.岛屿的最大面积(bfs, dfs)

dfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return 0;
            grid[i][j] = 0; //标记已访问
            int u = dfs(i+1, j), r = dfs(i, j+1), d = dfs(i-1, j), l = dfs(i, j-1);
            return u+r+d+l+1;
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == 1) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
            return 0;
        }
        grid[i][j] = 0
        u, l, d, r := dfs(i+1, j), dfs(i, j-1), dfs(i-1, j), dfs(i, j+1)
        return u+l+d+r+1
    }

    ans := 0
    for i, row := range grid {
        for j, x := range row {
            if x == 1 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```

这个dfs想不出来的原因啊，我感觉是不会分析`子问题`，子问题分析不出来就导致了不知道如何写返回值，最后开始我想写的是u=dfs(i+1,j)+1，r=dfs(i,j+1)+1以此类推，最后返回u+r+d+l，这样答案是不正确的，答案中`return u+r+d+l+1;`指的就是当前位置，这样才不会重复计算。写的过程中还有一个错误，就是边界条件的判断上，`i >= grid.size() || j >= grid[0].size()`一定要有等于号，不然会导致grid[i] [j]下标越界



bfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int n = grid.size(), m = grid[0].size();
        queue<pair<int, int>> q;
        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                int cnt = 0;
                if(grid[i][j] == 1) {
                    q.push({i, j});
                    cnt++;
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1) {
                                q.push({tx, ty});
                                grid[tx][ty] = 0;
                                cnt++;
                            }
                        }
                    }
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    n, m := len(grid), len(grid[0])
    for i, row := range grid {
        for j, val := range row {
            cnt := 0
            if val == 1 {
                q = append(q, [2]int{i, j})
                grid[i][j] = 0
                cnt++
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k :=  0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1 {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = 0
                            cnt++
                        } 
                    }
                }
            }
            ans = max(ans, cnt)
        }
    }
    return ans
}
```





##  2024.考试的最大困扰度(滑动窗口)

```cpp
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k) {
        int ans = 0, left = 0;
        int cnt[2]{};
        for(int right = 0; right < answerKey.size(); right++) {
            cnt[answerKey[right] >> 1 & 1]++;
            while(cnt[0] > k && cnt[1] > k) cnt[answerKey[left++] >> 1 & 1]--;
            ans = max(ans, right-left+1);
        }
        return ans;
    }
};
```



```go
func maxConsecutiveAnswers(answerKey string, k int) int {
    ans, left := 0, 0
    cnt := [2]int{}
    for right, ch := range answerKey {
        cnt[ch >> 1 & 1]++
        for cnt[0] > k && cnt[1] > k {
            cnt[answerKey[left] >> 1 & 1]--
            left++
        }
        ans = max(ans, right-left+1)
    }
    return ans
}
```

好久没做过滑动窗口的题目了，这个呢好像和之前做过的有点不一样，这个题的意思其实是让你求出这个滑动窗口的窗口最大值，而以前做过的题目呢都类似于给出了窗口的大小，然后让你求什么什么的。但是总的来说其实好像意思都是一样的，在右端移动的过程中因为题干中的某些限定条件，从而导致左端点也要跟着移动



##  2860.让所有学生保持开心的分组方法数(排序)

```cpp
class Solution {
public:
    int countWays(vector<int>& nums) {
        ranges::sort(nums);
        int ans = nums[0] > 0;
        for(int i = 1; i < nums.size(); i++) {
            ans +=  nums[i-1] < i && i < nums[i];
        }
        return ans+1;
    }
};
```



```go
func countWays(nums []int) ( ans int) {
    sort.Ints(nums)
    if nums[0] > 0 {
        ans = 1
    }

    for i := 1; i < len(nums)-1; i++ {
        if nums[i-1] < i && i < nums[i] {
            ans++
        }
    }
    return ans+1
}
```

灵神的话确实说的好，遇事不决先排序，当所求的答案和顺序没有关系的时候可以先无脑排序一下，这一题就是如此，给出的条件就是和大小相关，所以排序之后可能就会让问题变得简单。然后就是可以枚举选的人数，得出以下关系式：满足`nums[i-1] < i && i < nums[i]`就让ans方案数累加



##  面试题16.19.水域大小(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;

        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= land.size() || j >= land[0].size() || land[i][j] != 0) return 0;
            land[i][j] = 1;
            int res = 1;
            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(dx == 0 && dy == 0) continue;
                    res += dfs(i+dx, j+dy);
                }
            }
            return res;
        };

        for(int i = 0; i < land.size(); i++) {
            for(int j = 0; j < land[0].size(); j++) {
                if(land[i][j] == 0) {
                    ans.push_back(dfs(i, j));
                }
            }
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```



```go
func pondSizes(land [][]int) []int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(land) || j >= len(land[0]) || land[i][j] != 0 {
            return 0
        }
        land[i][j] = 1
        res := 1
        for dx := -1; dx <= 1; dx++ {
            for dy := -1; dy <= 1; dy++{
                if dx == 0 && dy == 0 {
                    continue
                }
                res += dfs(i+dx, j+dy)
            }
        }
        return res
    }

    ans := []int{}
    for i, row := range land {
        for j, val := range row {
            if val == 0 {
                ans = append(ans, dfs(i, j))
            }
        }
    }
    sort.Ints(ans)
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    vector<int> pondSizes(vector<vector<int>>& land) {
        vector<int> ans;
        queue<pair<int, int>> q;
        for(int i = 0; i < land.size(); i++) {
            for(int j = 0; j < land[0].size(); j++) {
                if(land[i][j] == 0) {
                    q.push({i, j});
                    land[i][j] = 1;
                    int cnt = 1;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int dx = -1; dx <= 1; dx++) {
                            for(int dy = -1; dy <= 1; dy++) {
                                if(dx == 0 && dy == 0) continue;
                                int tx = t.first+dx, ty = t.second+dy;
                                if(tx >= 0 && tx < land.size() && ty >= 0 && ty < land[0].size() && land[tx][ty] == 0) {
                                    q.push({tx, ty});
                                    cnt++;
                                    land[tx][ty] = 1;
                                }
                            }
                        }
                    }
                    ans.push_back(cnt);
                }
            }
        }
        ranges::sort(ans);
        return ans;
    }
};
```

这一题与之前不同的地方就在于对角线上也需要搜索，所以就变成了8个方向的dfs和bfs，这样可以直接用循环体来表示，这样更简洁

```cpp
int res = 1;
//枚举8个方向，(0,0)坐标除外，虽然不会超时，主要是没必要，因为已经标记过已访问
for(int dx = -1; dx <= 1; dx++) {
    for(int dy = -1; dy <= 1; dy++) {
        if(dx == 0 && dy == 0) continue;
        res += dfs(i+dx, j+dy);
    }
}
```





##  463.岛屿的周长(dfs)

```cpp
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        function<int(int, int)> dfs = [&](int i, int j) ->int {
            if(i < 0 || j < 0 || i >= n || j >= m) return 1;
            if(grid[i][j] == -1) return 0;
            else if(grid[i][j] == 0) return 1; 
            grid[i][j] = -1;	//已访问位
            int u = dfs(i+1, j), l = dfs(i, j-1), d = dfs(i-1, j), r = dfs(i, j+1);
            return u+l+d+r;
        };
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 1) return dfs(i, j);
            }
        }
        return 4;
    }
};
```

观察这个题的意思，其实和前面做的岛屿题目大致是一个意思，获取答案的方式不同而已，当下标越绝或者访问道的是水的时候就返回1，而当访问到陆地的时候返回0



##  2658.网格中鱼的最大数目(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        function<int(int, int)> dfs = [&](int i, int j) ->int {
            if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0) return 0;
            int res = grid[i][j];
            grid[i][j] = 0;
            int u = dfs(i-1, j), l = dfs(i, j-1), d = dfs(i+1, j), r = dfs(i, j+1);
            return u+l+d+r+res;
        };

        int ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] > 0) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func findMaxFish(grid [][]int) int {
    n, m := len(grid), len(grid[0])
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 0 {
            return 0
        }
        res := grid[i][j]
        grid[i][j] = 0
        u, l, d, r := dfs(i-1, j), dfs(i, j-1), dfs(i+1, j), dfs(i, j+1)
        return u+l+d+r+res
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val > 0 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int findMaxFish(vector<vector<int>>& grid) {
        int x[4] = {-1, 0, 1, 0};
        int y[4] = {0, -1, 0, 1};
        queue<pair<int, int>> q;
        int ans = 0;
        int n = grid.size(), m = grid[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] > 0) {
                    q.push({i, j});
                    int cnt = grid[i][j];
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int i = 0; i < 4; i++) {
                            int tx = t.first+x[i], ty = t.second+y[i];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] > 0) {
                                q.push({tx, ty});
                                cnt += grid[tx][ty];
                                grid[tx][ty] = 0;
                            }
                        }
                    }
                    ans = max(ans, cnt);
                }
            }
        }
        return ans;
    }
};
```





##  1034.边界着色(dfs)

```cpp
class Solution {
public:
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {
        int n = grid.size(), m = grid[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};  //代表上左下右
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        function<void(int, int, int)> dfs = [&](int i, int j, int val) {
            vis[i][j] = true;
            for(auto dir : dirs) {
                int dx = i+dir[0], dy = j+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m) {
                    if(vis[dx][dy] == true) continue;
                    //把这个理解成递归进入的入口
                    if(grid[dx][dy] == val) dfs(dx, dy, val);
                    else grid[i][j] = color;	//不是grid[dx][dy]=color
                } else {
                    grid[i][j] = color;
                }
            }
        };
        dfs(row, col, grid[row][col]);
        return grid;
    }
};
```

昨天感觉学的还不错，今天就来了个当头一棒，写的代码又臭又长，还不能过全部样例，这一个题解还出现了新的东西，就是表示这四个方向，在这里就必须要这样枚举四个方向了，而不能单纯的dfs(i+1,j)这样了，相比以前这一题的限定就更多了，所以只能枚举四个方向单独进行判断



##  1020.飞地的数量(dfs)

```cpp
class Solution {
public:
    int numEnclaves(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        int ans = 0;
        function<void(int, int)> dfs = [&](int i, int j) {
            grid[i][j] = 0;
            ans++;
            for(auto dir : dirs) {
                int dx = i+dir[0], dy = j+dir[1];
                if(dx < 0 || dy < 0 || dx >= n || dy >= m || grid[dx][dy] == 0) continue;
                dfs(dx, dy);
            }
            return;
        };

        for(int i = 0; i < n; i++) {
            if(grid[i][0] == 1) dfs(i, 0);
            if(grid[i][m-1] == 1) dfs(i, m-1);
        }
        for(int j = 0; j < m; j++) {
            if(grid[0][j] == 1) dfs(0, j);
            if(grid[n-1][j] == 1) dfs(n-1, j);
        }
        ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 1) dfs(i, j);
            }
        }
        return ans;
    }
};
```

主要问题在于不知道怎么解决我真的服了。。。还是多练习吧，主要思路是先将上下左右边界遍历一遍，当遇到1的时候就将所在连通分量全部变为0，这样就不会算在计数里面了，由于dfs函数体内对ans进行了修改，所以最后在找无法离开的陆地格子的时候就先要将ans清0即可



##  2684.矩阵中移动的最大次数(dfs)

```cpp
class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        int ans = 0, n = grid.size(), m = grid[0].size();
        int dirs[][2] = {{-1, 1}, {0, 1}, {1, 1}};
        function<void(int, int)> dfs = [&](int i, int j) {
            ans = max(ans, j);  //更新答案 这里的答案就是最远的列下标
            if(ans == m-1) return;
            for(auto dir : dirs) {
                int dx = i+dir[0], dy = j+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m && grid[i][j] < grid[dx][dy]) dfs(dx, dy);
            }
            grid[i][j] = 0;
        };
        for(int i = 0; i < n; i++) dfs(i, 0);
        return ans;
    }
};
```

好烦啊，怎么就是写不出来，就是搞不清楚什么时候dfs要有返回值，什么时候可以不需要有返回值





##  1254.统计封闭岛屿的数目(dfs)

```cpp
class Solution {
public:
    int closedIsland(vector<vector<int>>& grid) {
        int ans = 0, n = grid.size(), m = grid[0].size();
        auto dfs = [&](auto&& dfs, int i, int j) {
            if(i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1) return;
            grid[i][j] = 1;
            dfs(dfs, i-1, j);
            dfs(dfs, i, j-1);
            dfs(dfs, i+1, j);
            dfs(dfs, i, j+1);
        };

        for(int i = 0; i < n; i++) {
            int step = i == 0 || i == n-1 ? 1 : m-1;
            for(int j = 0; j < m; j += step) {
                dfs(dfs, i, j);
            }
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 0) {
                    ans++;
                    dfs(dfs, i, j);
                }
            }
        }
        return ans;
    }
};
```


```go
func closedIsland(grid [][]int) int {
    ans, n, m := 0, len(grid), len(grid[0])
    var dfs func(i, j int)
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= n || j >= m || grid[i][j] == 1 {
            return
        }
        grid[i][j] = 1
        dfs(i-1, j)
        dfs(i, j-1)
        dfs(i+1, j)
        dfs(i, j+1)
    }

    for i := range grid {
        step := 1
        if i > 0 && i < n-1 {
            step = m-1
        }
        for j := 0; j < m; j += step {
            dfs(i, j)
        }
    }

    for i, row := range grid {
        for j, val := range row {
            if val == 0 {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```

主要难点在于用什么算法能够实现题中的意思，这一题用的解法是：考虑到在网格边界的土地一定不是封闭岛屿，所以先dfs边界上的0，将他们变为1，然后再遍历非边界的0的联通分量，这个联通分量一定是符合封闭岛屿的。



##  130.被围绕的区域(dfs)

```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int n = board.size(), m = board[0].size();
        if(n == 0) return;
        auto dfs = [&](auto&& dfs, int i, int j) {
            if(i < 0 || j < 0 || i >= n || j >= m || board[i][j] != 'O') return;
            board[i][j] = 'A';
            dfs(dfs, i-1, j);
            dfs(dfs, i, j-1);
            dfs(dfs, i+1, j);
            dfs(dfs, i, j+1);
        };

        for(int i = 0; i < n; i++) {
            int step = i == 0 || i == n-1 ? 1 : m-1;
            for(int j = 0; j < m; j += step) {
                dfs(dfs, i, j);
            }
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(board[i][j] == 'A') board[i][j] = 'O';
                else if(board[i][j] == 'O') board[i][j] = 'X';
            }
        }
        return;
    }
};
```



```go
func solve(board [][]byte)  {
    var dfs func(i, j int)
    n, m := len(board), len(board[0])
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= n || j >= m || board[i][j] != 'O' {
            return
        }
        board[i][j] = 'A';
        dfs(i-1, j)
        dfs(i, j-1)
        dfs(i+1, j)
        dfs(i, j+1)
    }

    for i := range board {
        step := 1
        if i > 0 && i < n-1 {
            step = m-1
        }
        for j := 0; j < m; j += step {
            dfs(i, j)
        }
    }

    for i, row := range board {
        for j, val := range row {
            if val == 'A' {
                board[i][j] = 'O'
            } else if val == 'O' {
                board[i][j] = 'X'
            }
        }
    }
}
```

这个题和上一题还是很像的，也是想到了，就是先dfs边界条件，但是但是，感觉思维被上个题完全带走了，就想着dfs了边界后还要dfs里面的，其实并不需要啊，只需要遍历一遍这个board就行了。。。然后将相应元素替换掉就行了，啊啊啊啊啊感觉智商被践踏了。还有就是这个大写的O和0，我真的服了。。。





##  542.01矩阵(多源bfs)

```cpp
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        queue<pair<int, int>> q;
        int n = mat.size(), m = mat[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(mat[i][j] == 0) {
                    vis[i][j] = true;
                    q.push({i, j});
                }
            }
        }

        vector<vector<int>> dist(n, vector<int>(m, 0));
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t.first+dir[0], dy = t.second+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m && !vis[dx][dy]) {
                    dist[dx][dy] = dist[t.first][t.second]+1;
                    q.push({dx, dy});
                    vis[dx][dy] = true;
                }
            }
        }
        return dist;
    }
};
```

很明显了，这一题题干就是给出的求对应元素到0的最近距离，自己想好像真的不好想，主要是这个多元素困扰到了，这里题解给的方法是将所有`0`看成一个整体，也就是所说的超级0，前面两层for循环就是做的这个事情，与以往不同的是，这里需要定义一个vis数组来表示是否访问过，以前岛屿那种题型就是在数组原地修改来达到已经访问的意思，这里需要额外定义一个空间来记录，当然对于岛屿题目也可以自己定义一个vis数组，只不过就是内存消耗大了一点点，其余其实没有什么问题



##  994.腐烂的橘子(多源bfs)

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        vector<vector<int>> dist(n, vector<int>(m, 0));
        queue<pair<int, int>> q;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(grid[i][j] == 2) {
                    q.push({i, j});
                    vis[i][j] = true;
                }
            }
        }

        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t.first+dir[0], dy = t.second+dir[1];
                if(dx >= 0 && dx < n && dy >= 0 && dy < m && grid[dx][dy] == 1 && !vis[dx][dy]) {
                    vis[dx][dy] = true;
                    dist[dx][dy] = dist[t.first][t.second]+1;
                    q.push({dx, dy});
                }
            }
        }

        int ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(!vis[i][j] && grid[i][j] == 1) return  -1;
                ans = max(ans, dist[i][j]);
            }
        }
        return ans;
    }
};
```

自己独立顺利ac了，主要是学的上一题的01矩阵的官解方法，虽然代码冗长了一点，但是整体写的思路还是很流畅的，现在发现了bfs相对dfs要好写一点，虽然长是长了点，但是这种思路畅通的感觉就是爽一点





##  2684.矩阵中移动的最大次数(bfs)

```cpp
class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> vis(m, -1), q(m);
        iota(q.begin(), q.end(), 0);
        for(int j = 0; j < n-1; j++) {
            vector<int> nxt;
            for(auto i : q) {
                for(int k = max(i-1, 0); k < min(m, i+2); k++) {
                    if(vis[k] != j && grid[k][j+1] > grid[i][j]) {
                        vis[k] = j;
                        nxt.push_back(k);
                    }
                }
            }
            if(nxt.empty()) return j;
            q = move(nxt);
        }
        return n-1;
    }
};
```

这个是用的双数组的写法，和之前的dfs一样都有点看不懂，主要是灵神的方法和以往不一样，又是先遍历列，初始化都是第一列的元素，感觉遍历方式只要打破常规就感觉不是很好理解了



##  1926.迷宫中离入口最近的出口(bfs)

```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        queue<array<int, 3>> q;
        q.push({entrance[0], entrance[1], 0});
        maze[entrance[0]][entrance[1]] = '+';
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t[0]+dir[0], dy = t[1]+dir[1];
                if(dx >= 0 && dx < m && dy >= 0 && dy < n && maze[dx][dy] == '.') {
                    if(dx == 0 || dy == 0 || dx == m-1 || dy == n-1) return t[2]+1;
                    q.push({dx, dy, t[2]+1});
                    maze[dx][dy] = '+';
                }
            }
        }
        return -1;
    }
};
```

属于是给前两题整魔怔了，我还以刚刚的多源bfs来写，写道一半后发现这个起始点不就只有一个吗？啊？那我为什么要写多源的bfs啊，感觉这个题要比多源的bfs要简单一点，就是直接从起始点出发去找最近的一个边界，想是想到了，但是怎么维护这个补数就困扰到我了，所以在这个地方我不知道怎么写，看了官解之后原来就就是将每一个入队的元素多维护一个距离，这就是为什么队列q要定义成`queue<array<int, 3>> q;`



```cpp
class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int m = maze.size(), n = maze[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        queue<pair<int, int>> q;
        q.push({entrance[0], entrance[1]});
        maze[entrance[0]][entrance[1]] = '+';
        int ans = 0;
        while(!q.empty()) {
            int sz = q.size();
            //一层一层的遍历
            for(int k = 0; k < sz; k++) {
                auto t = q.front();
                q.pop();
                for(auto dir : dirs) {
                    int dx = t.first+dir[0], dy = t.second+dir[1];
                    if(dx >= 0 && dx < m && dy >= 0 && dy < n) {
                        if(maze[dx][dy] == '.') {
                            q.push({dx, dy});
                            maze[dx][dy] = '+';
                        }
                    } else if(t.first != entrance[0] || t.second != entrance[1]) {
                        return ans;
                    }
                }
            }

            ans++;
        }
        return -1;
    }
};
```

这是题解区中的另外一个bfs，这个也挺妙的，就是相当于以那个出发点做出一个层序遍历，最后返回的那个值就是层序遍历的最小层数，然后我就按照它那样改，改到后面发现怎么跑都不对，然后仔细发现原来是还要套一层for循环，这个for循环也挺好理解，就是一层一层的遍历这个队列q，然后每次遍历一遍就将ans++，这也是个好方法啊！



##  2181.合并零之间的节点(链表)

```cpp
class Solution {
public:
    ListNode* mergeNodes(ListNode* head) {
        ListNode* tail = head;
        for(ListNode* cur = head->next; cur->next; cur = cur->next) {
            if(cur->val) tail->val += cur->val;
            else {
                tail = tail->next;
                tail->val = 0;
            }
        }
        tail->next = nullptr;
        return head;
    }
};
```



```go
func mergeNodes(head *ListNode) *ListNode {
    tail := head
    for cur := head.Next; cur.Next != nil; cur = cur.Next {
        if cur.Val != 0 {
            tail.Val += cur.Val
        } else {
            tail = tail.Next
            tail.Val = 0
        }
    }
    tail.Next = nil
    return head
}
```

也是很久没有刷过链表的题目了，至少是不会写出报错的代码哈哈哈还是知足了，但是自己写的不知道为啥返回的空数据，看了灵神的题解还是舒服啊，直接在链表原地修改，整体的思想就是在所有val节点和都放到了tail所指的节点上了，这个tail指针一定是在cur指针之前的，所以可以直接修改tail的值



##  1091.二进制矩阵中的最短路径(bfs)

```cpp
class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        queue<array<int, 3>> q;
        int n = grid.size();
        if(grid[0][0] != 0) return -1;
        q.push({0, 0, 1});
        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(int i = -1; i <= 1; i++) {
                for(int j = -1; j <= 1; j++) {
                    if(i == 0 && j == 0) continue;
                    int dx = i+t[0], dy = j+t[1];
                    if(dx >= 0 && dx < n && dy >= 0 && dy < n && grid[dx][dy] == 0) {
                        if(dx == n-1 && dy == n-1) return t[2]+1;
                        q.push({dx, dy, t[2]+1});
                        grid[dx][dy] = 1;
                    }
                }
            }
        }
        return n == 1 ? 1 : -1;
    }
};
```

这个题和1926其实如出一辙，甚至感觉比1926要简单一点



##  1765.地图中的最高点(多源bfs)

```cpp
class Solution {
public:
    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {
        int m = isWater.size(), n = isWater[0].size();
        int dirs[][2] = {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
        vector<vector<int>> ans(m, vector<int>(n, 0));
        queue<array<int, 2>> q;
        for(int i = 0; i < m; i++) {
            for(int j  = 0; j < n; j++) {
                if(isWater[i][j] == 1) {
                    isWater[i][j] = 2;
                    q.push({i, j});
                }
            }
        }

        while(!q.empty()) {
            auto t = q.front();
            q.pop();
            for(auto dir : dirs) {
                int dx = t[0]+dir[0], dy = t[1]+dir[1];
                if(dx >= 0 && dx < m && dy >= 0 && dy < n && isWater[dx][dy] == 0) {
                    q.push({dx, dy});
                    ans[dx][dy] = ans[t[0]][t[1]]+1;
                    isWater[dx][dy] = 2;
                }
            }
        }
        return ans;
    }
};
```

这种容易把什么看成多源点的多源bfs还是会做了，就像这一题一样，很明显就是要将这个水域的格子看成一个超级源点，然后将这些源点依次bfs，bfs的过程中维护ans二维数组即可



##  1456.定长子串中元音的最大数目(定长滑动窗口)

```cpp
class Solution {
public:
    int maxVowels(string s, int k) {
        int cnt = 0, ans = 0;
        auto check = [&](char c) {
            return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
        };
        for(int i = 0; i < s.size(); i++) {
            cnt += check(s[i]);
            if(i < k-1) continue;
            ans = max(ans, cnt);
            cnt -= check(s[i-k+1]);
        }
        return ans;
    }
};
```



```go
func maxVowels(s string, k int) int {
    ans, cnt := 0, 0
    var check func(c byte) int
    check = func(c byte) int {
        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {
            return 1
        }
        return 0
    }
    for i, c := range s {
        cnt += check(byte(c))
        if i < k-1 {
            continue
        }
        ans = max(ans, cnt)
        cnt -= check(byte(s[i-k+1]))
    }
    return ans
}
```





##  643.子数组最大平均数(定长滑动窗口)

```cpp
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        double ans = INT_MIN, tmp = 0;
        for(int i = 0; i < nums.size(); i++) {
            tmp += nums[i];
            if(i < k-1) continue;
            ans = max(ans, tmp/k);
            tmp -= nums[i-k+1];
        }
        return ans;
    }
};
```





##  1343.大小为k且平均值大于等于阈值的子数组数目(定长滑动窗口)

```cpp
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        double sum = 0;
        int cnt = 0;
        for(int i = 0; i < arr.size(); i++) {
            sum += arr[i];
            if(i < k-1) continue;
            cnt += sum/k >= threshold;
            sum -= arr[i-k+1];
        }
        return cnt;
    }
};
```



```go
func numOfSubarrays(arr []int, k int, threshold int) int {
    ans, sum := 0, 0
    for i, x := range arr {
        sum += x
        if i < k-1 {
            continue
        }

        if sum/k >= threshold {
            ans++
        }
        sum -= arr[i-k+1]
    }
    return ans
}
```





##  2090.半径为k的子数组平均值(定长滑动窗口)

```cpp
class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        vector<int> ans(nums.size(), -1);
        long long sum = 0;
        if(k == 0) return nums;
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            if(i < 2*k) continue;
            //cout << sum << " ";
            ans[i-k] = sum/(2*k+1);
            sum -= nums[i-2*k];
        }
        return ans;
    }
};
```



```go
func getAverages(nums []int, k int) []int {
    ans := make([]int, len(nums))
    sum := 0
    for i, x := range nums {
        if i < k || i+k >= len(nums) {
            ans[i] = -1
        }
        sum += x
        if i >= 2*k {
            ans[i-k] = sum/(2*k+1)
            sum -= nums[i-2*k]
        }
    }
    return ans
}
```

第一直觉其实是想的是前缀和来写这道题，但是由于知道这是一个滑动窗口的题所以还是用滑动窗口来写了，但是仔细来看，其实这何尝不是一个前缀和的题呢？这一题和前面几道题有一点点的区别，主要是体现在下标处，搞清楚对应的下标，这一题就很好写了



##  2379.得到k个黑块的最少涂色次数(定长滑动窗口)

```cpp
class Solution {
public:
    int minimumRecolors(string blocks, int k) {
        int cnt[2]{}, ans = 101;
        for(int i = 0; i < blocks.size(); i++) {
            cnt[blocks[i]&1]++;
            if(i < k-1) continue;
            ans = min(ans, cnt[1]);
            cnt[blocks[i-k+1]&1]--;
        }
        //cout << (int)'W' << " " << (int)'B'; //偶是B
        return ans;
    }
};
```

知道方法和模板做题就是要快啊！感觉要是以前的话真不一定想得到这个是滑动窗口类型的题目了，这里也是一次性写出了我认为最简单的写法了，cnt数组用来分别计数W和B，发现这个W和B的ascii值奇偶性不同，就用了这个简便的写法。



##  2576.求出最多标记下标(二分答案、双指针)

二分答案：

```cpp
class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        
        //主要是弄清楚它是哪两个数进行比较判断的 不能是第一个和最后一个数比较 如果最小的数被最大的数取走了那么就不能符合题意了，其实有一点贪心的感觉
        auto check = [&](int k) {
            for(int i = 0; i < k; i++) {
                if(nums[i]*2 > nums[n-k+i]) return false;
            }
            return true;
        };

        //开区间写法
        int left = 0, right = n/2+1;    //left写成-1也行，主要是这一题k能等于0，所以初始化成了0，常理开区间的话应该初始化成-1
        while(left+1 < right) {
            int mid = (left+right)/2;
            (check(mid) ? left : right) = mid;
        }
        return left*2;
    }
};
```



双指针

```cpp
class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0, n = nums.size();
        for(int j = (n+1)/2; j < n; j++) {
            if(nums[i]*2 <= nums[j]) i++;
        }
        return i*2;
    }
};
```



```go
func maxNumOfMarkedIndices(nums []int) int {
    sort.Ints(nums)
    i, n := 0, len(nums)
    for j := (n+1)/2; j < n; j++ {
        if nums[i]*2 <= nums[j] {
            i++
        }
    }
    return 2*i
}
```

双指针的主要思想其实和二分答案是一样的，关键是要弄懂是和哪两个数进行比较。通过这一题也是了解了二分答案是个什么意思了，在判断二分答案方法的时候有一种思路，见下面总结归纳



##  1652.拆炸弹(定长滑动窗口)

```cpp
class Solution {
public:
    vector<int> decrypt(vector<int>& code, int k) {
        int n = code.size();
        vector<int> ans(n);
        int r = k > 0 ? k+1 : n;
        k = abs(k);
        int sum = reduce(code.begin()+r-k, code.begin()+r);
        for(int i = 0; i < code.size(); i++) {
            ans[i] = sum;
            sum += code[r%n]-code[(r-k)%n];
            r++;
        }
        return ans;
    }
};
```



```go
func decrypt(code []int, k int) []int {
    n := len(code)
    ans := make([]int, n)
    r := k+1
    if k < 0 {
        r = n
        k = -k
    }

    sum := 0
    for _, x := range code[r-k:r] {
        sum += x
    }

    for i := range code {
        ans[i] = sum
        sum += code[r%n]-code[(r-k)%n]
        r++
    }
    return ans
}
```

这一题竟然是简单题？？？我丢，我想的方法要分三种情况，然后每种情况一个for循环，我寻思着这也太麻烦了把，所以还是来看题解了。确实还是个定长滑动窗口，但是我感觉不是很明显，主要是题解很灵性的将k大于0和k小于0的情况都放在一起了，无论是哪种k的情况，其实滑动窗口都是往右移动的，只不过就是滑动窗口的起始位置不同而已。修改左右边界`sum += code[r%n]-code[(r-k)%n];`刚开始还看不懂是为什么，直到最后弄明白了这个r到底是什么意思，这个r是用来维护滑动窗口的右边界的，那么其左边界的下标就是[r-k]了，还有非常重要的一点是这个滑动窗口的区间是一个左闭右开的，这一题我感觉要是这个区间没搞明白的话也很难弄清楚这个下标之间的关系的，很容易导致下标越界之类的错误



##  1052.爱生气的书店老板(定长滑动窗口)

```cpp
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int cnt[2]{}, max1 = 0;
        for(int i = 0; i < customers.size(); i++) {
            cnt[grumpy[i]] += customers[i];
            if(i < minutes-1) continue;
            max1 = max(cnt[1], max1);
            cnt[1] -= grumpy[i-minutes+1] ? customers[i-minutes+1] : 0;
        }
        return cnt[0]+max1;
    }
};
```



```go
func maxSatisfied(customers []int, grumpy []int, minutes int) int {
    cnt := make([]int, 2)
    max1 := 0
    for i, x := range customers {
        cnt[grumpy[i]] += x
        if i < minutes-1 {
            continue
        }
        max1 = max(max1, cnt[1])
        if grumpy[i-minutes+1] == 1 {
            cnt[1] -= customers[i-minutes+1]
        }
    }
    return cnt[0]+max1
}
```

新题新题！但是仔细一看呢我觉得和前面做的2379还是有一点像的，对！确实就是一种类型的题目，诶哟当时那个题我也是用cnt[2]数组来做的，其实就是数量上的一点点偏差，这里累加的是customer[i]，前面的题只需要累加1就行了，再就是grumpy数组其实就是对应的2379的奇偶性！其它方面基本上没什么改变，定长滑动窗口内只需要维护cnt[1]的最大值就行了，所以在左侧元素移除滑动窗口的时候只需要对cnt[1]进行操作，二cnt[0]是我们一定要算入在最终答案的



##  2841.几乎唯一子数组的最大和(定长滑动窗口)

```cpp
class Solution {
public:
    long long maxSum(vector<int>& nums, int m, int k) {
        long long ans = 0, sum;
        unordered_map<int, int> cnt;
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            cnt[nums[i]]++;
            if(i < k-1) continue;
            if(cnt.size() >= m) {
                ans = max(ans, sum);
            }
            int out = nums[i-k+1];
            sum -= out;
            if(--cnt[out] == 0) cnt.erase(out);
        }
        return ans;
    }
};
```



```go
func maxSum(nums []int, m int, k int) (ans int64) {
    sum := int64(0)
    cnt := map[int]int{}
    for _, x := range nums[:k-1] {
        sum += int64(x)
        cnt[x]++
    }

    for i, in := range nums[k-1:] {
        sum += int64(in)
        cnt[in]++
        if len(cnt) >= m {
            ans = max(ans, sum)
        }
        out := nums[i]
        sum -= int64(out)
        cnt[out]--
        if cnt[out] == 0 {
            delete(cnt, out)
        }
    }
    return
}
```

这段代码不是一比一转换过来的，go代码是先循环前k-1个数，然后再对后面的数循环的，cpp代码是直接从头循环到尾。这一题也是差了一点点自己ac了，主要是差在了表达m个不同的数上，题解直接用的`cnt.size()`真的是妙中之妙啊，用了这么多的键、值，原来这里直接用size来表示不同元素的个数，天呐。正是因为这个，在退出元素更新哈希表cnt之后需要对其进行判空操作，如果为空了的话就需要它把这段内存空间删掉，也就是`cnt.erase(out)`，不然`cnt.size()`只会越来越大导致出错



##  2461.长度为k子数组中的最大和(定长滑动窗口)

```cpp
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        long long ans = 0, sum = 0;
        for(int i = 0; i < nums.size(); i++) {
            sum += nums[i];
            cnt[nums[i]]++;
            if(i < k-1) continue;
            if(cnt.size() == k) ans = max(ans, sum);
            int out = nums[i-k+1];
            sum -= out;
            if(--cnt[out] == 0) cnt.erase(out);
        }
        return ans;
    }
};
```



```go
func maximumSubarraySum(nums []int, k int) int64 {
    ans, sum := int64(0), int64(0)
    cnt := map[int]int{}
    for i, x := range nums {
        sum += int64(x)
        cnt[x]++
        if i < k-1 {
            continue
        }
        if len(cnt) == k {
            ans = max(ans, sum)
        }
        out := nums[i-k+1]
        sum -= int64(out)
        cnt[out]--
        if cnt[out] == 0 {
            delete(cnt, out)
        }
    }
    return ans
}
```

和昨天做的那一题很像！主要是要会用哈希表cnt，除了要满足滑动窗口的大小之外还需要满足k个不同的元素，这里还是用`cnt.size()`来表示



##  1423.可获得的最大点数(定长滑动窗口)

```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int n = cardPoints.size();
        int r = n, sum = reduce(cardPoints.begin()+r-k, cardPoints.begin()+r), ans = 0;
        //cout << reduce(cardPoints.begin(), cardPoints.end())-96 << sum;
        if(n == k) return sum;
        while(r%n < k) {
            ans = max(ans, sum);
            sum += cardPoints[r%n]-cardPoints[(r-k)%n];
            r++;
        }
        //cout << r;
        int t = reduce(cardPoints.begin()+(r-k)%n, cardPoints.begin()+r%n);
        return max(ans, t);
    }
};
```

顺利地自己ac了这道题，但是感觉有点不普遍性，最开始没有int t那一行还有4个样例不能通过，经过自己的debug应该就是最后一次没有参与循环，我感觉是边界的问题，加上这最后一步也是顺利解决了，但是看了一眼题解和他们的代码好像差别挺大的哈哈哈，这一题我主要是联想到了1652.拆炸弹的问题，以最后一个元素为右边界的长度为k的滑动窗口往前移动，然后就是找准边界r%n<k，退出循环即可。明白了，我其实是灵神的代码的反方向，还不错！



```cpp
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        int sum = reduce(cardPoints.begin(), cardPoints.begin()+k), ans = sum;
        for(int i = 1; i <= k; i++) {
            sum += cardPoints[cardPoints.size()-i]-cardPoints[k-i];
            ans = max(ans, sum);
        }
        return ans;
    }
};
```

灵神的题解主要是没有用到循环数组，他这个是巧妙运用了下标之间的关系来表示出入元素的，实在是简洁！



##  2390.从字符串中移除星号(栈)

```cpp
class Solution {
public:
    string removeStars(string s) {
        string ans = "";
        for(char c : s) {
            if(c == '*') ans.pop_back();
            else ans.push_back(c);
        }
        return ans;
    }
};
```



```go
func removeStars(s string) string {
    ans := []byte{}
    for _, c := range s {
        if c == '*' {
            ans = ans[:len(ans)-1]
        } else {
            ans = append(ans, byte(c))
        }
    }
    return string(ans)
}
```

典型的栈类型的邻项消除题目



##  3.无重复字符的最长子串(不定长滑动窗口)

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int l = 0, ans = 0;
        unordered_set<char> window;
        for(int r = 0; r < s.size(); r++) {
            while(window.count(s[r])) window.erase(s[l++]);
            window.insert(s[r]);
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```

从最开始入门的时候一点看不懂题解，到现在来看好像也就那么一回事，其实好像并没有那么难吧。这里使用`unordered_set容器`，要比map好用且简洁一点，但是set容器是不能有`window[s[r]]++`这种操作的，只能用内置的insert函数，复习一下set的几个函数`插入：：insert() 删除：erase() 个数/是否存在：count()`



##  3090.每个字符最多出现两次的最长子字符串(不定长)

```cpp
class Solution {
public:
    int maximumLengthSubstring(string s) {
        int ans = 0, l = 0;
        unordered_map<int, int> cnt;
        for(int r = 0; r < s.size(); r++) {
            cnt[s[r]-'0']++;
            while(cnt[s[r]-'0'] > 2) cnt[s[l++]-'0']--;
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func maximumLengthSubstring(s string) int {
    cnt := make([]int, 26)
    ans := 0
    l := 0
    for i, b := range s {
        b -= 'a'
        cnt[b]++
        for cnt[b] > 2 {
            cnt[s[l]-'a']--
            l++
        }
        ans = max(ans, i-l+1)
    }
    return ans
}
```

和上一题基本上是一样的，就是条件变成了小于等于2了





##  1493.删掉一个元素以后全为1的最长子数组(不定长)

```cpp
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int ans = 0, cnt[2]{}, l = 0;
        for(int r = 0; r < nums.size(); r++) {
            cnt[nums[r]]++;
            while(cnt[0] > 1) cnt[nums[l++]]--;
            ans = max(ans, r-l);
        }
        return ans;
    }
};
```

感觉没做出来就是差在了哈希表的使用上，这里由于nums仅是一个二进制数组，所以只有两个元素，这里就使用的是哈希数组来计数。



##  1208.尽可能使字符串相等(不定长)

```cpp
class Solution {
public:
    int equalSubstring(string s, string t, int maxCost) {
        int cnt = 0, cost = 0, ans = 0, l = 0;
        for(int r = 0; r < s.size(); r++) {
            cost += abs(s[r]-t[r]);
            cnt++;
            if(cost > maxCost) {
                cost -= abs(s[l]-t[l]);
                l++;
                cnt--;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```

与前面的题基本上没有什么差别，就是多了一个计数器cnt来记录修改的字符串个数，其它还是按照模板套入进去就行了



##  1184.公交站间的距离(数组)

```cpp
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int sum = reduce(distance.begin(), distance.end()), ans = 0;
        if(start > destination) swap(start, destination);
        for(int i = start; i < destination; i++) ans += distance[i];
        return min(ans, sum-ans);
    }
};
```

wa了一发，没有注意到start可以小于destination，所以在循环之前判断一下大小，如果start要小的话就交换一下



##  2730.找到最长的半重复子字符串(不定长)

```cpp
class Solution {
public:
    int longestSemiRepetitiveSubstring(string s) {
        int l = 0, same = 0, ans = 1;
        for(int r = 1; r < s.size(); r++) {
            if(s[r] == s[r-1] && ++same > 1) {
                for(l++; s[l] != s[l-1]; l++);
                same = 1;
            }
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func longestSemiRepetitiveSubstring(s string) int {
    ans, l, same := 1, 0, 0
    for r := 1; r < len(s); r++ {
        if s[r] == s[r-1] {
            same++
            if same > 1 {
                l++
                for s[l] != s[l-1] {
                    l++
                }
            }
        }
        ans = max(ans, r-l+1)
    }
    return ans
}
```

感觉这个题和之前的不定长有点不一样，主要是这个半重复子字符串的定义，当遇到相邻两字的时候一般都是`s[r]和s[r-1]`这种比较



##  2332.坐上 公交的最晚时间(模拟、双指针)

```cpp
class Solution {
public:
    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {
        ranges::sort(buses);
        ranges::sort(passengers);
        int j = 0, c;
        //模拟上车
        for(int t : buses) {
            for(c = capacity; c && j < passengers.size() && passengers[j] <= t; c--) j++;
        }

        j--;
        int ans = c ? buses.back() : passengers[j];	//还可以容纳乘客和不能容纳乘客的情况写在一起了
        while(j >= 0 && ans == passengers[j]) {
            j--;
            ans--;
        }
        return ans;
    }
};
```



```go
func latestTimeCatchTheBus(buses []int, passengers []int, capacity int) int {
    sort.Ints(buses)
    sort.Ints(passengers)
    j, c := 0, 0
    for _, t := range buses {
        for c = capacity; c > 0 && j < len(passengers) && passengers[j] <= t; c-- {
            j++
        }
    }

    j--
    ans := buses[len(buses)-1]
    if c <= 0 {
        ans = passengers[j]
    }
    for j >= 0 && ans == passengers[j] {
        j--
        ans--
    }
    return ans
}
```

这应该可以说是我目前为止做过最难的一个模拟题了。无论是模拟上车还是插队，这个过程都感觉很陌生，都不是熟悉的循环结构



##  904.水果成篮(不定长)

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> hash;
        int ans = 0, l = 0;
        for(int r = 0; r < fruits.size(); r++) {
            hash[fruits[r]]++;
            while(hash.size() > 2) {
                int out = fruits[l];
                hash[out]--;
                l++;
                if(hash[out] == 0) hash.erase(out);
            }
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func totalFruit(fruits []int) int {
    cnt := map[int]int{}
    ans, l := 0, 0
    for r := range fruits {
        cnt[fruits[r]]++
        for len(cnt) > 2 {
            out := fruits[l]
            cnt[out]--
            l++
            if cnt[out] == 0 {
                delete(cnt, out)
            }
        }
        ans = max(ans, r-l+1)
    }
    return ans
}
```

和前面的大多数题都一样，求滑动窗口的长度，限定条件都是类型，直接用哈希表中的内置函数`size()`来表示不同元素的个数



##  1695.删除子数组的最大得分(不定长)

```cpp
class Solution {
public:
    int maximumUniqueSubarray(vector<int>& nums) {
        unordered_map<int, int> cnt;
        int ans = 0, l = 0, sum = 0;
        for(int r = 0; r < nums.size(); r++) {
            cnt[nums[r]]++;
            sum += nums[r];
            while(cnt.size() != r-l+1) {
                int out = nums[l];
                l++;
                sum -= out;
                if(--cnt[out] == 0) cnt.erase(out);
            }
            ans = max(ans, sum);
        }
        return ans;
    }
};
```



```go
func maximumUniqueSubarray(nums []int) int {
    ans, sum, l := 0, 0, 0
    cnt := map[int]int{}
    for r, x := range nums {
        cnt[x]++
        sum += x
        for len(cnt) != r-l+1 {
            out := nums[l]
            l++
            sum -= out
            cnt[out]--
            if cnt[out] == 0 {
                delete(cnt, out)
            }
        }
        ans = max(ans, sum)
    }
    return ans
}
```





##  2958.最多k个重复元素的最长子数组(不定长)

```cpp
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        int ans = 0, l = 0;
        for(int r = 0; r < nums.size(); r++) {
            cnt[nums[r]]++;
            while(cnt[nums[r]] > k) cnt[nums[l++]]--;
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func maxSubarrayLength(nums []int, k int) int {
    cnt := map[int]int{}
    ans, l := 0, 0
    for r, x := range nums {
        cnt[x]++
        for cnt[x] > k {
            out := nums[l]
            cnt[out]--
            l++
        }
        ans = max(ans, r-l+1)
    }
    return ans
}
```

差点被不同元素给带偏了，这一题其实就是只要保证`cnt[nums[r]]`的个数小于等于k就行，然后维护ans数组长度即可



##  2779.数组的最大美丽值(不定长、差分数组)

```cpp
class Solution {
public:
    int maximumBeauty(vector<int>& nums, int k) {
        ranges::sort(nums);
        int ans = 0, l = 0;
        for(int r = 0; r < nums.size(); r++) {
            while(nums[r]-nums[l] > 2*k) l++;
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func maximumBeauty(nums []int, k int) int {
    sort.Ints(nums)
    ans, l := 0, 0
    for r := range nums {
        for nums[r]-nums[l] > 2*k {
            l++
        }
        ans = max(ans, r-l+1)
    }
    return ans
}
```

今天终于做到了一个有新意的题了！需要一点思维和数学！瞬间让我打鸡血的感觉了 看完题目我还挺纳闷求子序列长度的问题咋就在滑动窗口的题单里呢？看完题解真的就是恍然大悟，以前好像还遇到过类似的问题，时间久了应该是忘了，这一看完题解真的是豁然开朗。首先这个题与顺序是无关的，排序之后问题就转化成了最长子数组长度的问题了。然后就是画数轴找到满足最长子数组的边界条件`nums[r]-nums[l] <= 2*k`只有这样才能使得操作变成一个相同的元素，写这一题的时候我也在想，肯定得换种思路去想问题，肯定不是把这个数组变成某个元素然后再去计数求子序列长度，这样的模拟肯定是不对且超时的。



**差分数组**

```cpp
class Solution {
public:
    int maximumBeauty(vector<int>& nums, int k) {
        ranges::sort(nums);
        int m = nums.back();
        vector<int> diff(m+2);
        for(int x : nums) {
            diff[max(x-k, 0)]++;
            diff[min(x+k+1, m+1)]--;
        }
        int sum = 0, ans = 0;
        for(auto d : diff) {
            sum += d;
            ans = max(ans, sum);
        }
        return ans;
    }
};
```

差分数组就是从另外一个角度去思考问题的，将这nums所有元素变成区间的形式，然后最后让你求的是覆盖区间的最大重叠区间，也确实是典型的差分的意思，但这里就是要考虑边界的问题，很容易负边界出错



##  2414.最长字母连续子字符串的长度(快慢指针)

```cpp
class Solution {
public:
    int longestContinuousSubstring(string s) {
        int l = 0, ans = 1, n = s.size();
        for(int r = 1; r < n; r++) {
            if(s[r]-s[r-1] != 1) l = r;
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func longestContinuousSubstring(s string) int {
    ans, l, n := 1, 0, len(s)
    for r := 1; r < n; r++ {
        if s[r]-s[r-1] != 1 {
            l = r
        }
        ans = max(ans, r-l+1)
    }
    return ans
}
```

连续做了几天的滑动窗口题目，这一题可以说是快速判断解法并ac了，有点类似于滑动窗口求窗口长度，但是又有点像快慢指针，总之刷题效果还是达到了！



##  1004.最大连续1的个数III(不定长)

```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int cnt[2]{}, l = 0, ans = 0;
        for(int r = 0; r < nums.size(); r++) {
            cnt[nums[r]]++;
            while(cnt[0] > k) cnt[nums[l++]]--;
            ans = max(ans, r-l+1);
        }
        return ans;
    }
};
```



```go
func longestOnes(nums []int, k int) int {
    cnt := [2]int{}
    ans, l := 0, 0
    for r := range nums {
        cnt[nums[r]]++
        for cnt[0] > k {
            cnt[nums[l]]--
            l++
        }
        ans = max(ans, r-l+1)
    }
    return ans
}
```

用哈希数组cnt来计数n和1的个数，当cnt[0]>k时需要改变窗口左边界的大小



##  1658.将x减到0的最小操作数(不定长、正难则反)

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int target = reduce(nums.begin(), nums.end())-x;
        if(target < 0) return -1;
        int ans = -1, n = nums.size(), l = 0, sum = 0;
        for(int r = 0; r < n; r++) {
            sum += nums[r];
            while(sum > target) sum -= nums[l++];
            if(sum == target) ans = max(ans, r-l+1);
        }
        return ans < 0 ? -1 : n-ans;
    }
};
```



```go
func minOperations(nums []int, x int) int {
    target := 0
    for _, val := range nums {
        target += val
    }
    target -= x
    if target < 0 {
        return -1
    }
    ans, l, n, sum := -1, 0, len(nums), 0
    for r, val := range nums {
        sum += val
        for sum > target {
            sum -= nums[l]
            l++
        }
        if sum == target {
            ans = max(ans, r-l+1)
        }
    }
    if ans < 0 {
        return -1
    } else {
        return n-ans
    }
}
```

自己的思路是用循环数组来写，但是发现想不出窗口的起点应该在哪里，所以还是看了提示。读了一下提示的英文大概意思就是求最大满足target的数组长度，然后用数组长度减去这个长度就是最终求得的最小长度，也就是操作数，正难则反这个思路确实很重要！然后就是在这一题中也要注意这个x的范围，它是有可能大于nums[i]的，所以在遍历前如果target<0的话直接返回-1，如果不这样写的话可能会导致下标l越界，当时自己写的时候改了好久才发现，下面是自己ac的代码：

```cpp
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int sum = reduce(nums.begin(), nums.end())-x;
        //cout << sum;
        int l = 0, ans = 0, t = 0, n = nums.size(), flag = 0;
        for(int r = 0; r < nums.size(); r++) {
            t += nums[r];
            while(t > sum && l <= r) t-= nums[l++];
            if(t == sum) ans = max(ans, r-l+1), flag = 1;
        }
        if(ans == 0 && flag == 1) return n;
        return n-ans == n? -1 : n-ans;
    }
};
```





##  2516.每种字符至少取k个(正难则反、滑动窗口)

```cpp
class Solution {
public:
    int takeCharacters(string s, int k) {
        //'a' == 97
        int cnt[3]{};
        for(char c : s) cnt[c-'a']++;
        if(min(cnt[0], k)+min(cnt[1], k)+min(cnt[2], k) < 3*k) return -1;   //这里是和k取min而不是2，第一遍写的是2
        int n = s.size();
        int l = 0, ans = -1;
        cnt[0] -= k, cnt[1] -= k, cnt[2] -= k;
        for(int r = 0; r < n; r++) {
            cnt[s[r]-'a']--;
            while(cnt[0] < 0 || cnt[1] < 0 || cnt[2] < 0) cnt[s[l++]-'a']++;
            ans = max(ans, r-l+1);
        }
        return n-ans;
    }
};
```

自己独立ac了这道题！虽然有点点小错误在于取min的时候最开始k写成了示例的2导致wa了一发



##  209.长度最小的子数组(不定长)

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int ans = n+1, l = 0, sum = 0;
        for(int r = 0; r < n; r++) {
            sum += nums[r];
            while(sum >= target) {
                ans = min(ans, r-l+1);
                sum -= nums[l++];
            }
        }
        return ans == n+1 ? 0 : ans;
    }
};
```



```go
func minSubArrayLen(target int, nums []int) int {
    l, ans, sum := 0, len(nums)+1, 0
    for r, x := range nums {
        sum += x
        for sum >= target {
            ans = min(ans, r-l+1)
            sum -= nums[l]
            l++
        }
    }
    if ans == len(nums)+1 {
        return 0
    }
    return ans
}
```

题目要求总和大于等于...没看清题我真的服了。与以往不同的是这个ans更新答案在while循环体内，而且这一句一定要在缩小左边界之前，否则结果不正确



##  2374.边积分最高的节点(哈希、区分unorederd_map和map)

```cpp
class Solution {
public:
    int edgeScore(vector<int>& edges) {
        map<int, long long> hash;
        for(int i = 0; i < edges.size(); i++) {
            hash[edges[i]] += i;
        }
        long long mx = -1, ans = -1;
        for(auto& [i, label] : hash) {
            cout << i;
            if(label > mx) {
                mx = max(mx, label);
                ans = i;
            }
        }
        //cout << hash[0] << hash[1];
        return ans;
    }
};
```

这一题也是属于是知识漏洞了，wa了一发主要是因为没有开long long。另外一点就是`unordered_map`和`map`的区别了，前者通过哈希记录之后是不会保证键值是有序的，因为它的实现原理是哈希表，而对于map而言，它的实现原理是红黑树，他在每次操作后都会排序一次，所以用map进行哈希之后会保证键值是有序的。这一题要用哈希表解决就一定要保证哈希表的键值是有序的，这样才能保证返回的是编号最小的那个



##  125.验证回文串(字符串)

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        string ans = "";
        for(char c : s) {
            if(isalnum(c)) {
                ans += tolower(c);
            }
        }
        s = ans;
        reverse(ans.begin(), ans.end());
        return ans == s;
    }
};
```

本来是双指针的题，干脆借这个题来学一下关于string的api，对于string的一些api总是不清楚：

- `slower(char c)` 是否为小写字母
- `isupper(char c)` 是否为大写字母
- `isdigit(char c)` 是否为数字
- `isalpha(char c)` 是否为字母
- `isalnum(char c)` 是否为字母或者数字
- `toupper(char c)` 字母小转大
- `tolower(char c)` 字母大转小



##  1750.删除字符串两端相同字符后的最短长度(双指针)

```cpp
class Solution {
public:
    int minimumLength(string s) {
        int l = 0, r = s.size()-1;
        string ans = s;
        while(l < r && s[l] == s[r]) {
            char c = s[l];
            while(l <= r && s[l] == c) l++;
            while(l <= r && s[r] == c) r--;
        }
        return r-l+1;
    }
};
```



```go
func minimumLength(s string) int {
    l, r := 0, len(s)-1
    for l < r && s[l] == s[r] {
        c := s[l]
        for l <= r && s[l] == c {
            l++
        }
        for l <= r && s[r] == c {
            r--
        }
    }
    return r-l+1
}
```

双指针第一题，很明显的题意，只能用双指针去扫。简便写法就是要设置一个标准，也就是`char c = s[l];`不然容易出现下标错误。双指针，目前容易遇到的错误就是死循环。



##  2105.给植物浇水II(双指针、模拟)

```cpp
class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int l = 0, r = plants.size()-1, ca = capacityA, cb = capacityB, ans = 0;
        while(l < r) {
            if(ca < plants[l]) {
                ans++;
                ca = capacityA;
            }
            ca -= plants[l++];
            if(cb < plants[r]) {
                ans++;
                cb = capacityB;
            }
            cb -= plants[r--];
        }
        if(l == r && max(ca, cb) < plants[l]) ans++;
        return ans;
    }
};
```



```go
func minimumRefill(plants []int, capacityA int, capacityB int) int {
    l, r, ca, cb, ans := 0, len(plants)-1, capacityA, capacityB, 0
    for l < r {
        if ca < plants[l] {
            ans++
            ca = capacityA
        }
        ca -= plants[l]
        l++
        if cb < plants[r] {
            ans++
            cb = capacityB
        }
        cb -= plants[r]
        r--
    }
    if l == r && max(ca, cb) < plants[l] {
        ans++
    }
    return ans
}
```

唉，感觉没什么状态了，这感觉就是做阅读题，步骤完完全全告诉你怎么写了，也有可能是英语的问题吧，刚开始英文读题还是有点困难的，看完题解后知后觉是可以同步的，还得练还得练！



##  977.有序数组的平方(双指针)

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int l = 0, r = n-1, cnt = n-1;
        while(l <= r) {
            if(abs(nums[l]) <= abs(nums[r])) {
                ans[cnt--] = nums[r]*nums[r];
                r--;
            } else {
                ans[cnt--] = nums[l]*nums[l];
                l++;
            }
        }
        return ans;
    }
};
```



```go
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        int l = 0, r = n-1, cnt = n-1;
        while(l <= r) {
            if(abs(nums[l]) <= abs(nums[r])) {
                ans[cnt--] = nums[r]*nums[r];
                r--;
            } else {
                ans[cnt--] = nums[l]*nums[l];
                l++;
            }
        }
        return ans;
    }
};
```

用双指针能够达到O(n)复杂度，考虑到数组是有序的，所以用双指针遍历一遍数组即可



##  658.找到k个最接近的元素(双指针)

```cpp
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int r = lower_bound(arr.begin(), arr.end(), x)-arr.begin();
        int l = r-1;
        while(k--) {
            if(l < 0) r++;  //全都大于等于x
            else if(r >= arr.size()) l--;   //全都小于x
            else if(x-arr[l] <= arr[r]-x) l--;
            else r++;
        }
        return vector<int>(arr.begin()+l+1, arr.begin()+r);
    }
};
```



```go
func findClosestElements(arr []int, k int, x int) []int {
    r := sort.SearchInts(arr, x) //go的二分查找
    l := r-1
    for ; k > 0; k-- {
        if l < 0 {
            r++
        } else if r >= len(arr) {
            l--
        } else if x-arr[l] <= arr[r]-x {
            l--
        } else {
            r++
        }
    }
    return [l+1 : r]
}
```

这是一个从中间向两边的一个双指针，首先二分查找找到第一个大于等于x的下标，然后向两边扩展指针，最后返回的数组就是`a[l+1, r]`cpp的迭代器和go的切片是一样的，都是左闭右开的



##  713.乘积小于k的子数组(滑动窗口)

```cpp
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        long long sum = 1;
        int l = 0, ans = 0;
        for(int r = 0; r < nums.size(); r++) {
            sum *= nums[r];
            while(l <= r && sum >= k) sum /= nums[l++];
            ans += r-l+1;
        }
        return ans;
    }
};
```



```go
func numSubarrayProductLessThanK(nums []int, k int) int {
    l, sum, ans := 0, 1, 0
    for r, x := range nums {
        sum *= x
        for l <= r && sum >= k {
            sum /= nums[l]
            l++
        }
        ans += r-l+1
    }
    return ans
}
```

滑动窗口求子数组个数，这个子数组个数的求法以前也是总结过了的，就是闭区间的[l,r]用r-l+1累加到ans中，就是最终的结果，表示以nums[r]结尾长度为r-l+1的子串的个数



##  1014.最佳观景点(枚举右、维护左)

```cpp
class Solution {
public:
    int maxScoreSightseeingPair(vector<int>& values) {
        int mx = values[0], ans = 0;
        for(int i = 1; i < values.size(); i++) {
            ans = max(ans, mx+values[i]-i);
            mx = max(mx, values[i]+i);
        }
        return ans;
    }
};
```



```go
func maxScoreSightseeingPair(values []int) int {
    ans, mx := 0, values[0]
    for i := 1; i < len(values); i++ {
        ans = max(ans, mx+values[i]-i)
        mx = max(mx, values[i]+i)
    }
    return ans
}
```

顺利ac，做过的题了，一眼就发现了枚举右、维护左！



##  2207.字符串中最多数目的子序列(贪心)

```cpp
class Solution {
public:
    long long maximumSubsequenceCount(string text, string pattern) {
        int cntx = 0, cnty = 0;
        long long ans = 0;
        char x = pattern[0], y = pattern[1];
        for(char t : text) {
            if(t == y) {
                ans += cntx;
                cnty++;
            } 
            if(t == x) cntx++;
        }
        ans = ans+max(cntx, cnty);
        return ans;
    }
};
```



```go
func maximumSubsequenceCount(text string, pattern string) int64 {
    cntx, cnty, ans := 0, 0, int64(0)
    x, y := pattern[0], pattern[1]
    for i := range text {
        c := text[i]
        if c == y {
            ans += int64(cntx)
            cnty++
        }
        if c == x {
            cntx++
        }
    }
    return ans + int64(max(cntx, cnty))
}
```

首先拿到这个题判断用dp做，思考了一下发现不太好想递推关系，结果是贪心！看似patterm的两个字符可以插入text的任意一个位置，但实际上要求符合条件的最多子序列个数就应该选一个插入最前或者最后的位置，这样才能保证数目最多，然后就是这个数目的计算上，感觉有点像枚举右维护左的思维，然后就是循环体内，代码中没有对pattern中字符相等做出特例的判断，所以一定要先判断字符y，累加答案之后再判断x。再就是自己写`unordered_map`中出现的错误，也是当x和y相等的时候，哈希表`cnt[x]`和`cnt[y]`其实表示的是同一个键值对，当时看了好久没看出来



##  2962.统计最大元素出现至少k次的数组(滑动窗口)

```cpp
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        long long ans = 0;
        int l = 0;
        int mx = ranges::max(nums);
        int cnt = 0;
        for(int x : nums) {
            cnt += x == mx;
            while(cnt == k) cnt -= nums[l++] == mx;
            ans += l;
        }
        return ans;
    }
};
```



```go
func countSubarrays(nums []int, k int) int64 {
    mx := slices.Max(nums)
    cnt, ans, l := 0, int64(0), 0
    for _, x := range nums {
        if x == mx {
            cnt++
        }
        for cnt == k {
            if nums[l] == mx {
                cnt--
            }
            l++
        }
        ans += int64(l)
    }
    return ans
}
```

巩固周赛遇到的题型，滑动窗口求符合条件的子数组个数，越长越合法，一般是`ans+=l`来计算符合条件的子数组个数



##  2799.统计完全子数组的数目(滑动窗口)

```cpp
class Solution {
public:
    int countCompleteSubarrays(vector<int>& nums) {
        unordered_set<int> st(nums.begin(), nums.end());
        int k = st.size();
        unordered_map<int, int> cnt;
        int l = 0, r = 0, ans = 0;
        for(int x : nums) {
            cnt[x]++;
            while(cnt.size() >= k) {
                int out = nums[l];
                if(--cnt[out] == 0) cnt.erase(out);
                l++;
            }
            ans += l;
        }
        return ans;
    }
};
```

还是越长越合法的类型的题目



##  2302.统计得分小于k的子数组数目(滑动窗口)

```cpp
class Solution {
public:
    long long countSubarrays(vector<int>& nums, long long k) {
        long long sum = 0, ans = 0;
        int l = 0;
        for(int r = 0; r < nums.size(); r++) {
            sum += nums[r];
            while(sum*(r-l+1) >= k) sum -= nums[l++];
            ans += r-l+1;
        }
        return ans;
    }
};
```



```go
func countSubarrays(nums []int, k int64) int64 {
    sum, ans := int64(0), int64(0)
    l := 0
    for r, x := range nums {
        sum += int64(x)
        for sum*int64(r-l+1) >= k {
            sum -= int64(nums[l])
            l++
        }
        ans += int64(r-l+1)
    }
    return ans
}
```

这是滑动窗口求子数组长度的另一种题型了，属于是越短越合法，这样ans累加的答案是`ans+=r-l+1`，有点不同的是这一题需要一个前缀和数组来维护前缀和，这个题的意思也是很明确需要前缀和，但是题解给出的是动态维护前缀和，这样写法更简洁。前缀和分为预处理前缀和与动态维护前缀和，有时候某种题型只能用动态来维护前缀和，这也是因题而异



##  2762.不间断子数组(滑动窗口)

```cpp
class Solution {
public:
    long long continuousSubarrays(vector<int>& nums) {
        map<int, int> cnt;
        long long ans = 0;
        int l = 0;
        for(int r = 0; r < nums.size(); r++) {
            cnt[nums[r]]++;
            while(cnt.rbegin()->first-cnt.begin()->first > 2) {
                int out = nums[l++];
                if(--cnt[out] == 0) cnt.erase(out);
            }
            ans += r-l+1;
        }
        return ans;
    }
};
```

滑动窗口和哈希表的新应用，这里用的哈希表是map类型的，之前总结过，map和unordered_map的区别就是map保存数据之后是有序的而unordered_map保存数据之后不是有序的。在这一题中，一定是得保证这个子数组最大元素和最小元素之差要小于等于2.然后就是如何找到最后一个元素呢？这里不是用的`.back()`函数，这里用的是`r.begin()`迭代器，也就是记住吧留个映像，主要是map确实没怎么用过。然后其它的地方和越短越合法是一个步骤，`ans+=r-l+1`



##  2540.最小公共值(双指针)

```cpp
class Solution {
public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        int i = 0, j = 0;
        while(i < nums1.size() && j < nums2.size()) {
            if(nums1[i] < nums2[j]) i++;
            else if(nums1[i] > nums2[j]) j++;
            else return nums1[i];
        }
        return -1;
    }
};
```



```go
func getCommon(nums1 []int, nums2 []int) int {
    i, j := 0, 0
    for i < len(nums1) && j < len(nums2) {
        if nums1[i] < nums2[j] {
            i++
        } else if nums1[i] > nums2[j] {
            j++
        } else {
            return nums1[i]
        }
    }
    return -1
}
```

很明显题干中给出了是一个已经排序好了的两个数组，这里就可以利用排序的性质然后双指针就行了



##  88.合并两个有序数组(双指针)

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p = m+n-1, p1 = m-1, p2 = n-1;
        while(p2 >= 0) {
            if(p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[p--] = nums1[p1--];
            } else {
                nums1[p--] = nums2[p2--];
            }
        }
    }
};
```



```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    p1, p2, p := m-1, n-1, m+n-1
    for p2 >= 0 {
        if p1 >= 0 && nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p--
            p1--
        } else {
            nums1[p] = nums2[p2]
            p--
            p2--
        }
    }
}
```

突然感觉这个逆向思维很重要！特别是对于双指针来说，遍历方向的不同确实能解决不同的题目！之前是逆向思维对于解题的思考，现在是逆向遍历的思维，为什么要逆向遍历呢？这里是为了解决数组赋值过程中的覆盖问题，你只有从后往前遍历才能保证不会覆盖数组。然后就是强调写法上面，我觉得要扣的细节还挺多的，类似于这样的合并问题一定要考虑的点就是哪个数组会有剩余，需要把剩余的部分全部补上，有时候出题人就会故意出这种陷阱。在这个循环中，当nums1数组遍历完之后就是将nums2补全了，所以循环的条件就是`while(p2>=2)`，因为是加载nums1数组的后面所以只需要在里面的if语句中判断p1的值即可



##  2570.合并两个二维数组-求和法(双指针、哈希表)

双指针法：

```cpp
class Solution {
public:
    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {
        vector<vector<int>> ans;
        int i = 0, j = 0;
        while(i < nums1.size() && j < nums2.size()) {
            auto x = nums1[i], y = nums2[j];
            if(x[0] == y[0]) {
                x[1]+=y[1];
                ans.push_back(x);
                i++;
                j++;
            } else if(x[0] < y[0]) {
                ans.push_back(x);
                i++;
            } else {
                ans.push_back(y);
                j++;
            }
        }

        while(i < nums1.size()) {
            auto x = nums1[i];
            ans.push_back(x);
            i++;
        }
        while(j < nums2.size()) {
            auto y = nums2[j];
            ans.push_back(y);
            j++;
        }
        return ans;
    }
};
```



哈希表法：

```cpp
class Solution {
public:
    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {
        map<int, int> mp;
        for(auto n1 : nums1) mp[n1[0]] += n1[1];
        for(auto n2 : nums2) mp[n2[0]] += n2[1];
        vector<vector<int>> ans;
        for(auto [x, y] : mp) ans.push_back({x,y});
        return ans;
    }
};
```

自己写的双指针简直就是屎山，写的自己都有点不想写了，最后还是硬着头皮写下去了，至少还是过了，一看题解发现蛙神写的好简洁！理解的角度不同方法就不一样，而且简洁很多！哈希法是用的容器map而不是unordered_map，由于这里最后是要返回以键值排序的ans序列，所以这里的哈希表一定是带有自动排序功能的map，还是挺好理解的！



##  LCP18.早餐组合(双指针)

题解：

```cpp
class Solution {
public:
    int breakfastNumber(vector<int>& staple, vector<int>& drinks, int x) {
        ranges::sort(staple);
        ranges::sort(drinks);
        int i = 0, j = drinks.size()-1, ans = 0, mod = 1e9+7;
        for(int i = 0; i < staple.size(); i++) {
            while(j >= 0 && staple[i]+drinks[j] > x) j--;
            if(j == -1) return ans;
            ans = (ans+j+1)%mod;
        }
        return ans;
    }
};
```



```go
func breakfastNumber(staple []int, drinks []int, x int) int {
    sort.Ints(staple)
    sort.Ints(drinks)
    j, ans, mod := len(drinks)-1, 0, 1000000007
    for _, val := range staple {
        for j >= 0 && val+drinks[j] > x {
            j--
        }
        if j == -1 {
            return ans
        }
        ans = (ans+j+1)%mod
    }
    return ans
}
```



自己写的(超时了)：

```cpp
class Solution {
public:
    int breakfastNumber(vector<int>& staple, vector<int>& drinks, int x) {
        ranges::sort(staple);
        sort(drinks.rbegin(), drinks.rend());
        int i = 0, j = 0, ans = 0, mod = 1e9+7;
        for(int i = 0; i < staple.size(); i++) {
            for(int j = 0; j < drinks.size(); j++) {
                if(staple[i]+drinks[j] <= x) {
                    cout << drinks.size()-j << " ";
                    ans = (ans+drinks.size()-j)%mod;
                    break;
                }
            }
        }
        return ans;
    }
};
```

这一题加深了我对双指针的理解了，为什么我的代码会超时？那是因为每一次j都是从0开始的这样会比题解跑更多次，题解的意思是i从前往后遍历，j从后往前遍历，当i增大时，j只需要在上一层循环的位置左移即可，并不需要再从头开始，这是因为两个数组排序后具有单调性。





##  2073.买票需要的时间(循环数组)

```cpp
class Solution {
public:
    int timeRequiredToBuy(vector<int>& tickets, int k) {
        int ans = 0, n = tickets.size();
        for(int i = 0; tickets[k] > 0; i++) {
            if(tickets[i%n] > 0) {
                tickets[i%n]--;
                ans++;
            }
        }
        return ans;
    }
};
```



```go
func timeRequiredToBuy(tickets []int, k int) int {
    ans, n := 0, len(tickets)
    for i := 0; tickets[k] > 0; i++ {
        if tickets[i%n] > 0 {
            tickets[i%n]--
            ans++
        }
    }
    return ans
}
```

一般这种从对头操作完之后又回到队尾这种操作都是用循环数组来写，这一题还是很好想出来的



##  34.在排序数组中查找元素的第一个和最后一个位置

```cpp
class Solution {
public:

    //左闭右闭写法 [l, r]
    int lower_bound1(vector<int>& nums, int target) {
        int l = 0, r = nums.size()-1;
        //区间没有元素的状态是l>r 那么上一个状态(l<=r)就是循环条件
        while(l <= r) {
            int mid = l+(r-l)/2;
            if(nums[mid] < target) l = mid+1;
            else r = mid-1;
        }
        return l;
    }

    //左闭右开写法 [l, r)
    int lower_bound2(vector<int>& nums, int target) {
        int l = 0, r = nums.size();
        //区间没有元素的状态是l==r 那么上一个状态(l<r)就是循环条件
        while(l < r) {
            int mid = l+(r-l)/2;
            if(nums[mid] < target) l = mid+1;
            else r = mid;   //哪边是开区间，那边就不需要1
        }
        return l;   //return r也行
    }

    //左开右开写法 (l, r)
    int lower_bound3(vector<int>& nums, int target) {
        int l = -1, r = nums.size();
        //区间没有元素的状态是l+1==r 那么上一个状态(l+1<r)就是循环条件
        while(l+1 < r) {
            int mid = l+(r-l)/2;
            if(nums[mid] < target) l = mid;
            else r = mid;   //哪边是开区间，那边就不需要1
        }
        return l+1; //return 也行
    }

    vector<int> searchRange(vector<int>& nums, int target) {
        int start = lower_bound3(nums, target);
        if(start == nums.size() || nums[start] != target) return {-1, -1};
        int end = lower_bound1(nums, target+1)-1;
        return {start, end};
    }
};
```

属于是重温了，最近二分的题目遇到的太多了，之前算是浅浅了解了一下，这次系统性的刷一遍









##  总结归纳

###  并查集模板

```cpp
vector<int> uf(n);

//init
iota(uf.begin(), uf.end(), 0);

//find
auto find = [&] (auto&& find, int x) -> int {
    if(uf[x] != x) uf[x] = find(find, uf[x]);
    return uf[x];
};

//union
for(auto ... : ...) {
    if(...) {
        uf[find(find, ...)] = find(find, ...);
    }
}
```



###  网格dfs、bfs

大多数情况下两种方法都能解决，dfs代码看上去相对简洁一点，但是理解起来比较费劲，着重考虑子问题是否分析正确。在遇到这类问题的时候容易出现的几个错误：1、边界出错导致数组越界。2、没有更新已访问节点导致死循环。3、注意题干中所给的网格大小，通常在1000以内还是能够解决的不会超时

什么时候用dfs，什么时候用bfs呢？这两种方法其实在大部分情况看来两种都是能用用的方法，主流来说连通块问题用dfs，求最短路径用bfs





###  滑动窗口模板

**未知窗口大小求窗口大小---不定长滑动窗口**

```cpp
int solve(string answerKey) {
    int ans = 0, left = 0;
    int cnt[2]{};
    for(int right = 0; right < answerKey.size(); right++) {
        cnt[answerKey[right] >> 1 & 1]++;
        while(...) cnt[answerKey[left++] >> 1 & 1]--;	//可能维护计数、和之类的东西
        ans = max(ans, right-left+1);//求滑动窗口的大小
    }
    return ans;
}
```



**已知窗口大小**---步骤分为入、出、更新数据

```cpp
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> q;
    vector<int> res;
    for(int i = 0; i < nums.size(); i++)
    {
        //入
        while(!q.empty() && nums[i] >= nums[q.back()]) q.pop_back();
        q.push_back(i);

        //出
        if(i-q.front() >= k) q.pop_front();

        //记录数据
        if(i >= k-1) res.push_back(nums[q.front()]);
    }
    return res;
}
```

三个步骤：入、更新数据、出。几乎适用于所有定长滑动窗口的题目，当然，顺序不同代码逻辑就会有少许差异，总的来说这三个步骤一定是不能少的。一定是入、更新答案、出！

总结：解决最长、最短子数组长度、子数组个数





###  遇事不决先排序

当题中给出某些大小关系才能给出答案的字眼中，并且答案和顺序无关的时候可以先排序看看问题能不能变得简便很多





###  二分答案

判断这种方法有一个思路，就是答案具有一定的单调性，拿2576为例，这里的下标数目就是作为答案返回的，它的结果一定是偶数，这里用k来表示标记的下标对，那么最终返回的答案就是2 * k，然后就是对k进行判断，判断其单调性，什么意思呢？假设答案为k对，那么k-1对，k-2对一定是标记过了的，同理k+1对和k+2对一定是没有标记过的，就相当于k左边的都是符合条件的，k右边的都是不符合条件的，这也就是我们最开始用二分查找所对应的意思。所以和二分查找一样，最终的循环不变量也是left。所以二分答案的解题过程就是一个二分模板里面加上一个check函数，这个check函数需要自己来写，具体怎么实现就需要根据题意来写了





###  子序列长度问题转化成子数组长度(排序)

这来源于刷滑动窗口题单中出现的一个有意思的题目，题目中求的是某个条件下子序列的最大长度，但是通过对数组观察之后其实答案并没有顺序上的限定，所以当数组排序完之后就变成了求最长子数组的长度问题了，只能说这个问题转化十分巧妙，详情见2779.数组的最大美丽值



###  正难则反

这算是一个思考题目的策略吧，以1685为例，要求的是操作最小次数，问题可以转换成求和为target的最大子数组长度，然后用n减去这个长度就是最小操作次数。这种方法出现的情景可能比较少，主要是需要可行性的判断，在正面没有思路的时候就可以试试反面去想，也类似于遇事不决先排序吧，先判断一下是否能排序，如果能的话就先排序试试，说不定第一步就是需要排序的



###  前缀和、差分数组

好久没有写过前缀和、差分数组了，之所以写这一个总结单纯就是熟悉一下，最主要是在哪个平台写的题，这一次在牛客上遇到了月赛101中的D题，用到了前缀和+差分数组+差分数组再求一次前缀和。这也是和力扣刷的时候有点不同的地方，力扣好像还没有写过用数组将差分数组再求前缀和存储起来的题。然后就是最重要的下标问题，我认为好的解决办法就是拿第一个下标举例然后推



###  判断平方数

```cpp
int tmp = sqrt(num);
if(num == tmp*tmp) cout << "是平方数";
else cout << "不是平方数";
```





###  双指针

下标一定要写对，否则容易出现死循环



###  字符串api

- `slower(char c)` 是否为小写字母
- `isupper(char c)` 是否为大写字母
- `isdigit(char c)` 是否为数字
- `isalpha(char c)` 是否为字母
- `isalnum(char c)` 是否为字母或者数字
- `toupper(char c)` 字母小转大
- `tolower(char c)` 字母大转小



###  字符串时间的问题如何简化？---转化为秒

拿蓝桥算法季度赛4为例，第四题出现了一个较为复杂了判断时间先后的问题，输入的时候给出的时间样式大致为`HH:MM:SS`这种字符串的格式。这里的办法是先统一单位，将单位全部向小的转移，这可以在函数外实现，也可以用lambda表达式来实现。这样在输入之后直接都统一成了int类型了，这样会简化代码很多！

```cpp
auto trans = [&]() {
    string s;
    cin >> s;
    return stoi(s.substr(0, 2))*3600+stoi(s.substr(3, 2))*60+stoi(s.substr(6, 2));
}; 
```





###  数位之和两种写法---循环、字符串

```cpp
//写法一：
int target = 3487568927346, ans = 0;
for(int t = target; t > 0; t /= 10) ans += target%10;

//写法二：
int target = 3487568927346, ans = 0;
string s = to_string(target);
for(char c : s) ans += c-'0';
```





###  求素数的三种方法(式除法、埃式筛、线性筛或称欧拉筛)

也是接受了之前一直很难理解的东西了，果然以前弄不懂的最终还是会给自己一个暴击！这个求素数的题出现在牛客练习赛129上。
**试除筛**

```cpp
void solve() {
    int n;
    cin >> n;
    auto isprime = [&](int x) {
        if(x < 2) return false;
        for(int i = 2; i*i <= x; i++) {
            if(x%i == 0) return false;
        }
        return true;
    };
    //输出n以内的素数
    for(int i = 2; i <= n; i++) {
        if(isprime(i)) cout << i << " ";
    }
}
```

这里有一点点的优化就是`i*i <= x`，这是通过性质来判断的，如果i是x的一个因子，那么x/i也会是x的一个因子，这两个因子又分居在根号n的左右两端，所以循环条件在`i*i <= x`即可



**埃式筛**

```cpp
void solve() {
    int n;
    cin >> n;
    vector<bool> isPrime(n+1, true);
    for(int i = 2; i <= n; i++) {
        //是素数
        if(prime[i]) {
            for(int j = i*i; j <= n; j += i) {
                prime[j] = false;
            }
        }
    }

    for(int i = 2; i <= n; i++) {
        if(prime[i]) cout << i << " ";
    }
}
```

先判断是否为素数，如果为素数那么再进行将后面的合数筛选掉



**线性筛（欧拉筛）**

```cpp
void solve() {
    int n;
    cin >> n;
    vector<int> primes;
    vector<bool> isPrime(n+1, true);
    for(int i = 2; i <= n; i++) {
        //是素数
        if(isPrime[i]) primes.push_back(i);
        for(int j = 0; j < primes.size() && i*primes[j] <= n; j++) {
            isPrime[i*primes[j]] = false;
            if(i%primes[j] == 0) break;
        }
    }

    for(auto p : primes) cout << p << " ";
}
```

不同于埃式筛，这里是从最小质因数开始筛，因为埃式筛会有很多重复筛的地方，比如12和18，他们先后会被2和3筛，所以会有重复的地方，用线性筛就只会被2筛掉



###  快速幂

```cpp
auto quickPow = [&](ll x, ll n) {
    ll res = 1;
    while(n > 0) {
        if(n&1) res  = (res*x)%mod;
        x = x*x%mod;
        n >>= 1;
    }
    return res;
};
```

重新理解快速幂，这个函数是求以x为底数n次幂的结果，循环改变的量是指数，当最低位为1的时候累乘答案，指数n不断右移



