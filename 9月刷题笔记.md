#  9月刷题笔记

##  990.等式方程的可满足性(并查集)

```cpp
class Solution {
public:
    bool equationsPossible(vector<string>& equations) {
        vector<int> uf(26);
        iota(uf.begin(), uf.end(), 0);
        auto find = [&] (auto&& find, int x) -> int {
            if(uf[x] != x) uf[x] = find(find, uf[x]);
            return uf[x];
        };

        for(string eq : equations) {
            if(eq[1] == '=') {
                uf[find(find, eq[0]-'a')] = find(find, eq[3]-'a');
            }
        }

        for(string eq : equations) {
            if(eq[1] == '!') {
                int fa1 = find(find, eq[0]-'a');
                int fa2 = find(find, eq[3]-'a');
                if(fa1 == fa2) return false;
            }
        }
        return true;
    }
};
```

并查集模板好像都是两三个月前写的了，确实想不起来了，但是还是有一点点的回忆，照着笔记的模板写，再加上题解的解题思路也是写出了和灵神风格的代码了。解题思路是遍历equations两遍，分别是=和!，=用来将元素合并，!用来判断答案。



##  200.岛屿数量(dfs, bfs)

dfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        function<void(int, int)> dfs = [&] (int i, int j) {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[i].size() || grid[i][j] == '0') return;
            grid[i][j] = '0';
            dfs(i+1, j);
            dfs(i, j+1);
            dfs(i-1, j);
            dfs(i, j-1);
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    ans++;
                    dfs(i, j);
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    var dfs func(i, j int) //相当于少一个等号 多一个var
    dfs = func(i, j int) {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == '0' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i, j+1)
        dfs(i-1, j)
        dfs(i, j-1)
    }

    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                ans++
                dfs(i, j)
            }
        }
    }
    return ans
}
```



bfs:

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int ans = 0;
        deque<pair<int, int>> q;    //保存grid[i][j] == '1'的下标
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == '1') {
                    q.push_back({i, j});
                    grid[i][j] = '0';
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop_front();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < grid.size() && ty >= 0 && ty < grid[0].size() && grid[tx][ty] == '1') {
                                q.push_back({tx, ty});
                                grid[tx][ty] = '0';
                            }
                        }
                    }
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



```go
func numIslands(grid [][]byte) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    for i, row := range grid {
        for j, val := range row {
            if val == '1' {
                q = append(q, [2]int{i, j})
                val = '0'
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k := 0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < len(grid) && ty >= 0 && ty < len(grid[0]) && grid[tx][ty] == '1' {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = '0'
                        }
                    }
                }
                ans++;
            }
        }
    }
    return ans
}
```

二刷的题目，结果还是要看笔记才能做出来，但是起码好在看了笔记还是能写出正确答案差不多的样子，



##  695.岛屿的最大面积(bfs, dfs)

dfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        function<int(int, int)> dfs = [&](int i, int j) -> int {
            if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) return 0;
            grid[i][j] = 0; //标记已访问
            int u = dfs(i+1, j), r = dfs(i, j+1), d = dfs(i-1, j), l = dfs(i, j-1);
            return u+r+d+l+1;
        };

        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == 1) {
                    ans = max(ans, dfs(i, j));
                }
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
            return 0;
        }
        grid[i][j] = 0
        u, l, d, r := dfs(i+1, j), dfs(i, j-1), dfs(i-1, j), dfs(i, j+1)
        return u+l+d+r+1
    }

    ans := 0
    for i, row := range grid {
        for j, x := range row {
            if x == 1 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}
```

这个dfs想不出来的原因啊，我感觉是不会分析`子问题`，子问题分析不出来就导致了不知道如何写返回值，最后开始我想写的是u=dfs(i+1,j)+1，r=dfs(i,j+1)+1以此类推，最后返回u+r+d+l，这样答案是不正确的，答案中`return u+r+d+l+1;`指的就是当前位置，这样才不会重复计算。写的过程中还有一个错误，就是边界条件的判断上，`i >= grid.size() || j >= grid[0].size()`一定要有等于号，不然会导致grid[i] [j]下标越界



bfs:

```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int x[4] = {1, 0, -1, 0};
        int y[4] = {0, -1, 0, 1};
        int n = grid.size(), m = grid[0].size();
        queue<pair<int, int>> q;
        int ans = 0;
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[0].size(); j++) {
                int cnt = 0;
                if(grid[i][j] == 1) {
                    q.push({i, j});
                    cnt++;
                    grid[i][j] = 0;
                    while(!q.empty()) {
                        auto t = q.front();
                        q.pop();
                        for(int k = 0; k < 4; k++) {
                            int tx = t.first+x[k], ty = t.second+y[k];
                            if(tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1) {
                                q.push({tx, ty});
                                grid[tx][ty] = 0;
                                cnt++;
                            }
                        }
                    }
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```



```go
func maxAreaOfIsland(grid [][]int) int {
    x := []int{1, 0, -1, 0}
    y := []int{0, -1, 0, 1}
    q := [][2]int{}
    ans := 0
    n, m := len(grid), len(grid[0])
    for i, row := range grid {
        for j, val := range row {
            cnt := 0
            if val == 1 {
                q = append(q, [2]int{i, j})
                grid[i][j] = 0
                cnt++
                for len(q) > 0 {
                    t := q[0]
                    q = q[1:]
                    for k :=  0; k < 4; k++ {
                        tx, ty := t[0]+x[k], t[1]+y[k]
                        if tx >= 0 && tx < n && ty >= 0 && ty < m && grid[tx][ty] == 1 {
                            q = append(q, [2]int{tx, ty})
                            grid[tx][ty] = 0
                            cnt++
                        } 
                    }
                }
            }
            ans = max(ans, cnt)
        }
    }
    return ans
}
```











##  总结归纳

###  并查集模板

```cpp
vector<int> uf(n);

//init
iota(uf.begin(), uf.end(), 0);

//find
auto find = [&] (auto&& find, int x) -> int {
    if(uf[x] != x) uf[x] = find(find, uf[x]);
    return uf[x];
};

//union
for(auto ... : ...) {
    if(...) {
        uf[find(find, ...)] = find(find, ...);
    }
}
```



###  网格dfs、bfs

大多数情况下两种方法都能解决，dfs代码看上去相对简洁一点，但是理解起来比较费劲，着重考虑子问题是否分析正确。在遇到这类问题的时候容易出现的几个错误：1、边界出错导致数组越界。2、没有更新已访问节点导致死循环。3、注意题干中所给的网格大小，通常在1000以内还是能够解决的不会超时