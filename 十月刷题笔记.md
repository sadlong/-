#  十月刷题笔记

##  1385.两个数组间的距离值(二分)

```cpp
class Solution {
public:

    int lowerBound(vector<int>& arr, int target) {
        int l = 0, r = arr.size()-1;
        while(l <= r) {
            int mid = l+(r-l)/2;
            if(arr[mid] < target) l = mid+1;
            else r = mid-1;
        }
        return l;
    }

    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        ranges::sort(arr2);
        int n = arr2.size(), ans = 0;
        for(auto a : arr1) {
            int right = lowerBound(arr2, a), left = lowerBound(arr2, a)-1;
            bool ok = true;
            if(right < n) ok &= (arr2[right]-a>d);
            if(left >= 0 && left < arr2.size()) ok &= (a-arr2[left]>d);
            ans += ok;
        }
        return ans;
    }
};
```

这个题简单写法就是直接暴力写也能过，只不过如果数据范围变大的话那么就只能用二分法来写这道题了，根据题意我们需要从arr1中找x和所有arr2里的元素y满足|x-y|>d，这样就能把ans累加，其实完全不需要遍历整个数组arr2，当arr2排序后，只需要找到第一个大于等于x的y和第一个小于x的y，都满足|x-y|>d就能累加答案，只不过这里更难的点其实我觉得是边界的判断上，我自己写的怎么都不对，看了官解的确实思路基本上是一样的，但是就是不知道为啥自己就写不对，官解这种写法感觉也是写不出来。。。





##  2904.最短且字典序最小的美丽子字符串(滑动窗口)

```cpp
class Solution {
public:
    string shortestBeautifulSubstring(string s, int k) {
        if(count(s.begin(), s.end(), '1') < k) return "";
        string ans = s;
        int cnt[2]{}, l = 0;
        for(int r = 0; r < s.size(); r++) {
            cnt[s[r]-'0']++;
            while(cnt[1] > k || s[l] == '0') cnt[s[l++]-'0']--;
            if(cnt[1] == k) {
                string t = s.substr(l, r-l+1);
                if(t.size() <= ans.size() || t.size() == ans.size() && t < ans) ans = t;
            }
        }
        return ans;
    }

};
```



```go
func shortestBeautifulSubstring(s string, k int) string {
    if strings.Count(s, "1") < k {
        return ""
    }
    ans, cnt1, l := s, 0, 0
    for r, b := range s {
        cnt1 += int(b&1)
        for cnt1 > k || s[l] == '0' {
            cnt1 -= int(s[l]&1)
            l++
        }
        if cnt1 == k {
            t := s[l : r+1]
            if len(t) < len(ans) || len(t) == len(ans) && t < ans {
                ans = t
           }
        }
    }
    return ans
}
```

这属于是滑动窗口求最小的问题，这里的最小主要是字典序的最小，这一点有一点困扰我，等灵神回复我再会过来看看吧，主要是不理解为什么ans数组排序后输出ans数组标准输出11001在100011的后面。



##  2300.咒语和药水的成功对数(二分查找)

```cpp
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        vector<int> ans;
        int n = potions.size();
        ranges::sort(potions);
        auto lowerBound = [&](int x) {
            int l = 0, r = n-1;
            while(l <= r) {
                int mid = l+(r-l)/2;
                long long  t = (long long)x*potions[mid];
                if(t < success) l = mid+1;
                else r = mid-1;
            }
            return l;
        };
        for(auto s : spells) ans.push_back(n-lowerBound(s));
        return ans;
    }
};
```

对二分的一点点的变动，目标值变成了两个数组的乘积形式，题干中给出了大于等于的字样很明显就是让用二分的思维来解这个题了



##  2389.和有限的最长子序列(前缀和、二分查找)

```cpp
class Solution {
public:
    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {
        ranges::sort(nums);
        int n = nums.size();
        for(int i = 1; i < n; i++) nums[i] += nums[i-1];
        vector<int> ans;
        auto lowerbound = [&](int target) {
            int l = 0, r = n-1;
            while(l <= r) {
                int mid = l+(r-l)/2;
                if(nums[mid] < target) l = mid+1;
                else r = mid-1;
            }
            return l;
        };
        for(auto x : queries) ans.push_back(lowerbound(x+1));
        return ans;
    }
};
```

首先现在 nums数组上原地求前缀和，然后就是将题目中的问题转化，找到第一个元素和小于等于q[i]的子数组长度，这里之前总结过了，子序列长度的求法可以通过排序转化成求子串长度的问题



##  1170.比较字符串最小字母出现频次(二分查找)

```cpp
class Solution {
public:
    vector<int> numSmallerByFrequency(vector<string>& queries, vector<string>& words) {
        auto f = [&](string s) {
            ranges::sort(s);
            char c = s[0];
            int n = s.size();
            for(int i = 1; i < s.size(); i++) {
                if(s[i] != c) return i;
            }
            return n;
        };

        //将words数组转化成nums数组
        int n = words.size();
        vector<int> nums(n);
        for(int i = 0; i < n; i++) {
            nums[i] = f(words[i]);
        }
        ranges::sort(nums);

        auto lowerBound = [&](int target) {
            int l = -1, r = nums.size();
            while(l+1 < r) {
                int mid = l+(r-l)/2;
                if(nums[mid] < target) l = mid;
                else r = mid;
            }
            return r;
        };
        vector<int> ans;
        for(auto s : queries) {
            int t = f(s);
            ans.push_back(n-lowerBound(t+1));
        }
        return ans;
    }
};
```

转化问题！转化问题！转化问题！主要是转化问题的思想不是很到位，分析题目的时候还是想到了要排序的数组是words，然后就是要把这个words数组转化成nums数组，这很关键，然后将nums数组排序，这样就问题大致解决了



##  2080.区间内查询数字的频率(二分查找)

```cpp
class RangeFreqQuery {
public:
    unordered_map<int, vector<int>> pos;
    RangeFreqQuery(vector<int>& arr) {
        for(int i = 0; i < arr.size(); i++) pos[arr[i]].push_back(i);
    }
    
    int query(int left, int right, int value) {
        auto it = pos.find(value);
        if(it == pos.end()) return 0;
        const auto& a = it->second;
        auto lowerBound = [&](int target) {
            int l = -1, r = a.size();
            while(l+1 < r) {
                int mid = l+(r-l)/2;
                if(a[mid] < target) l = mid;
                else r = mid;
            }
            return r;
        };
        return lowerBound(right+1)-lowerBound(left);
    }

};

/**
 * Your RangeFreqQuery object will be instantiated and called as such:
 * RangeFreqQuery* obj = new RangeFreqQuery(arr);
 * int param_1 = obj->query(left,right,value);
 */
```

这属于是一个设计题，我觉得还是挺新颖的，是没有见过的类型的二分，要是能想到这种思路真的得要有一定的积累。最开始自己写的时候超时了，想着每一次query就创建一个数组t然后构建一个[left,right]的数组、排序后再二分找到这个value的第一个和最后一个下标，这样就能求出它出现的次数了，这样只能过部分样例，果然还是给卡住了，query调用的越多构造数组+排序的时间开销就会大很多，所以就超时了。

刚开始看灵神的代码理解起来还有点费劲，但是看完之后感觉给了我一个二分的一个很新颖的点，它是首先用哈希表来保存每个数出现的下标，用个列表存起来，所以哈希表的类型是`unordered_map<int, vector<int>> pos;`代表的是值到对应下标的映射集，这个就很巧妙！为什么呢？因为每个映射集是有序的！这样二分的就不再是value了而是二分的下标！也就是这里的left和right，我天哪真妙！



##  2563.统计公平数对的数目(枚举、二分查找)

```cpp
class Solution {
public:

    int lowerBound(vector<int> nums, int right, int target) {
        int l = 0, r = right;
        while(l <= r) {
            int mid = l+(r-l)/2;
            if(nums[mid] < target) l = mid+1;
            else r = mid-1;
        }
        return l;
    }

    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        ranges::sort(nums);
        //0 1 4 4 5 7
        long long ans = 0;
        for(int j = 0; j < nums.size(); j++) {
            auto r = upper_bound(nums.begin(), nums.begin()+j, upper-nums[j]);
            auto l = lower_bound(nums.begin(), nums.begin()+j, lower-nums[j]);
            ans += r-l;
        }
        return ans;
    }
};
```

不知道为什么这一题只能用库函数解决，自己写的二分法反而过不了，会爆内存，实在是不能理解。当然做完这一题后对二分又有了新的理解，第一点就是排序上，最开始自己想的时候没有想出来这个数组是能够排序的，排序其实是不会影响答案的，稳妥起见的话最好还是举个例子比较好，可能是第二个条件没有理解好，如果改成`lower <= nums[i] < nums[j] <= upper`的话就一定不能排序了。然后就是对二分的理解了，解题过程有一种枚举右+二分左的感觉，感觉大部分我看不出来的二分题就是这种感觉，不知道这样一种思路。还有就是循环不变量的思考，贴一个评论区的代码，对理解循环不变量有了新的认识：

```cpp
//返回的是第一个小于等于target的下标 这里的循环不变量是r
int lowerBound(vector<int> nums, int right, int target) {
    int l = 0, r = right;
    while(l <= r) {
        int mid = l+(r-l)/2;
        if(nums[mid] > target) r = mid-1;
        else l = mid-1;
    }
    return r;
}
```





##  2856.删除数对后的最小数组长度(哈希、二分、数学)

哈希：

```cpp
class Solution {
public:
    int minLengthAfterRemovals(vector<int>& nums) {
        unordered_map<int, int> cnt;
        int mx = 0, n = nums.size();
        for(auto x : nums) {
            cnt[x]++;
            mx = max(mx, cnt[x]);
        }
        return max(mx*2-n, n%2);
    }
};
```



二分：

```cpp
class Solution {
public:
    int minLengthAfterRemovals(vector<int>& nums) {
        int mx = 0, n = nums.size(), x = nums[n/2];
        mx = upper_bound(nums.begin(), nums.end(), x)-lower_bound(nums.begin(), nums.end(), x);
        return max(mx*2-n, n%2);	//n%2是考虑了mx*2<n的奇偶情况
    }
};
```



```go
func minLengthAfterRemovals(nums []int) int {
    n := len(nums)
    mx, x := 0, nums[n/2]
    mx = sort.SearchInts(nums, x+1)-sort.SearchInts(nums, x)
    return max(mx*2-n, n%2)
}
```



这一题主要是需要数学推导一下，需要从特殊到一般手玩一下这个题，感觉照着题单刷题容易陷入思维定式，题解的max函数用的相当巧妙，直接简化了ifelse的逻辑一行就搞定了三种不同情况，n%2是考虑了mx*2<n的奇偶情况，当mx * 2 > n的时候表明删不完最多的那个元素



##  1283.使结果不超过阈值的最小除数(二分答案)

```cpp
class Solution {
public:

    int check(vector<int> nums, int x) {
        int sum = 0;
        for(auto n : nums) {
            sum += (n+x-1)/x;
        }
        return sum;
    }

    int smallestDivisor(vector<int>& nums, int threshold) {
        int l = 0, r = ranges::max(nums);
        while(l+1 < r) {
            int mid = l+(r-l)/2;
            if(check(nums, mid) > threshold) l = mid; //表明除数小于threshold
            else r = mid;
        }
        return r;
    }
};
```

二分答案的第一题！虽然自己想不出来，但是好歹是看完题解能够明白这个二分答案是什么意思了！感觉顿悟了！为什么`if(check(nums, mid) > threshold)`对应的是`l = mid`，当商的和大于这个阈值的话就表明这个对应的除数应该小了，所以修改的是左边界，这里还是和二分查找有一点点的区别的！这里我试了一下左闭右开和左开右开的区间都是能写的，可是闭区间是写不了的，要不还是听灵神的吧，二分都用开区间写吧，主要是区间这一块的边界问题还是理解比较透彻了，几个区间的转化、边界修改还是改的出来的



##  2187.完成旅途的最少时间(二分答案)

```cpp
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        auto check = [&](long long x) {
            long long sum = 0;
            for(int t : time) {
                sum += x/t;
                if(sum >= totalTrips) return true;
            }
            return false;
        };
        long long l = ranges::min(time)-1, r = ranges::max(time)*(long long)totalTrips;
        while(l+1 < r) {
            long long mid = l+(r-l)/2;
            (check(mid) ? r : l) = mid;
        }
        return r;
    }
};
```

其实自己写的和题解还是很像的，它是在如果sum>=totoalTrips就直接返回了，因为这种情况下就是更新右边界，可能就是思考的时候错了，以为跟上一题是一样的，只不过这里是地板除。这样理解是不正确的。除了要会写check函数之外，还有一点很重要的就是你的check函数是和你的答案正相关还是负相关，这对二分答案还是很关键的，就比如上面的1283我写的check函数和那个最小的除数是负相关的关系，所以在改变l和r的时候就是反着来的了