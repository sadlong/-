#  十月刷题笔记

##  1385.两个数组间的距离值(二分)

```cpp
class Solution {
public:

    int lowerBound(vector<int>& arr, int target) {
        int l = 0, r = arr.size()-1;
        while(l <= r) {
            int mid = l+(r-l)/2;
            if(arr[mid] < target) l = mid+1;
            else r = mid-1;
        }
        return l;
    }

    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        ranges::sort(arr2);
        int n = arr2.size(), ans = 0;
        for(auto a : arr1) {
            int right = lowerBound(arr2, a), left = lowerBound(arr2, a)-1;
            bool ok = true;
            if(right < n) ok &= (arr2[right]-a>d);
            if(left >= 0 && left < arr2.size()) ok &= (a-arr2[left]>d);
            ans += ok;
        }
        return ans;
    }
};
```

这个题简单写法就是直接暴力写也能过，只不过如果数据范围变大的话那么就只能用二分法来写这道题了，根据题意我们需要从arr1中找x和所有arr2里的元素y满足|x-y|>d，这样就能把ans累加，其实完全不需要遍历整个数组arr2，当arr2排序后，只需要找到第一个大于等于x的y和第一个小于x的y，都满足|x-y|>d就能累加答案，只不过这里更难的点其实我觉得是边界的判断上，我自己写的怎么都不对，看了官解的确实思路基本上是一样的，但是就是不知道为啥自己就写不对，官解这种写法感觉也是写不出来。。。





##  2904.最短且字典序最小的美丽子字符串(滑动窗口)

```cpp
class Solution {
public:
    string shortestBeautifulSubstring(string s, int k) {
        if(count(s.begin(), s.end(), '1') < k) return "";
        string ans = s;
        int cnt[2]{}, l = 0;
        for(int r = 0; r < s.size(); r++) {
            cnt[s[r]-'0']++;
            while(cnt[1] > k || s[l] == '0') cnt[s[l++]-'0']--;
            if(cnt[1] == k) {
                string t = s.substr(l, r-l+1);
                if(t.size() <= ans.size() || t.size() == ans.size() && t < ans) ans = t;
            }
        }
        return ans;
    }

};
```



```go
func shortestBeautifulSubstring(s string, k int) string {
    if strings.Count(s, "1") < k {
        return ""
    }
    ans, cnt1, l := s, 0, 0
    for r, b := range s {
        cnt1 += int(b&1)
        for cnt1 > k || s[l] == '0' {
            cnt1 -= int(s[l]&1)
            l++
        }
        if cnt1 == k {
            t := s[l : r+1]
            if len(t) < len(ans) || len(t) == len(ans) && t < ans {
                ans = t
           }
        }
    }
    return ans
}
```

这属于是滑动窗口求最小的问题，这里的最小主要是字典序的最小，这一点有一点困扰我，等灵神回复我再会过来看看吧，主要是不理解为什么ans数组排序后输出ans数组标准输出11001在100011的后面。



##  2300.咒语和药水的成功对数(二分查找)

```cpp
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        vector<int> ans;
        int n = potions.size();
        ranges::sort(potions);
        auto lowerBound = [&](int x) {
            int l = 0, r = n-1;
            while(l <= r) {
                int mid = l+(r-l)/2;
                long long  t = (long long)x*potions[mid];
                if(t < success) l = mid+1;
                else r = mid-1;
            }
            return l;
        };
        for(auto s : spells) ans.push_back(n-lowerBound(s));
        return ans;
    }
};
```

对二分的一点点的变动，目标值变成了两个数组的乘积形式，题干中给出了大于等于的字样很明显就是让用二分的思维来解这个题了



##  2389.和有限的最长子序列(前缀和、二分查找)

```cpp
class Solution {
public:
    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {
        ranges::sort(nums);
        int n = nums.size();
        for(int i = 1; i < n; i++) nums[i] += nums[i-1];
        vector<int> ans;
        auto lowerbound = [&](int target) {
            int l = 0, r = n-1;
            while(l <= r) {
                int mid = l+(r-l)/2;
                if(nums[mid] < target) l = mid+1;
                else r = mid-1;
            }
            return l;
        };
        for(auto x : queries) ans.push_back(lowerbound(x+1));
        return ans;
    }
};
```

首先现在 nums数组上原地求前缀和，然后就是将题目中的问题转化，找到第一个元素和小于等于q[i]的子数组长度，这里之前总结过了，子序列长度的求法可以通过排序转化成求子串长度的问题



##  1170.比较字符串最小字母出现频次(二分查找)

```cpp
class Solution {
public:
    vector<int> numSmallerByFrequency(vector<string>& queries, vector<string>& words) {
        auto f = [&](string s) {
            ranges::sort(s);
            char c = s[0];
            int n = s.size();
            for(int i = 1; i < s.size(); i++) {
                if(s[i] != c) return i;
            }
            return n;
        };

        //将words数组转化成nums数组
        int n = words.size();
        vector<int> nums(n);
        for(int i = 0; i < n; i++) {
            nums[i] = f(words[i]);
        }
        ranges::sort(nums);

        auto lowerBound = [&](int target) {
            int l = -1, r = nums.size();
            while(l+1 < r) {
                int mid = l+(r-l)/2;
                if(nums[mid] < target) l = mid;
                else r = mid;
            }
            return r;
        };
        vector<int> ans;
        for(auto s : queries) {
            int t = f(s);
            ans.push_back(n-lowerBound(t+1));
        }
        return ans;
    }
};
```

转化问题！转化问题！转化问题！主要是转化问题的思想不是很到位，分析题目的时候还是想到了要排序的数组是words，然后就是要把这个words数组转化成nums数组，这很关键，然后将nums数组排序，这样就问题大致解决了



##  2080.区间内查询数字的频率(二分查找)

```cpp
class RangeFreqQuery {
public:
    unordered_map<int, vector<int>> pos;
    RangeFreqQuery(vector<int>& arr) {
        for(int i = 0; i < arr.size(); i++) pos[arr[i]].push_back(i);
    }
    
    int query(int left, int right, int value) {
        auto it = pos.find(value);
        if(it == pos.end()) return 0;
        const auto& a = it->second;
        auto lowerBound = [&](int target) {
            int l = -1, r = a.size();
            while(l+1 < r) {
                int mid = l+(r-l)/2;
                if(a[mid] < target) l = mid;
                else r = mid;
            }
            return r;
        };
        return lowerBound(right+1)-lowerBound(left);
    }

};

/**
 * Your RangeFreqQuery object will be instantiated and called as such:
 * RangeFreqQuery* obj = new RangeFreqQuery(arr);
 * int param_1 = obj->query(left,right,value);
 */
```

这属于是一个设计题，我觉得还是挺新颖的，是没有见过的类型的二分，要是能想到这种思路真的得要有一定的积累。最开始自己写的时候超时了，想着每一次query就创建一个数组t然后构建一个[left,right]的数组、排序后再二分找到这个value的第一个和最后一个下标，这样就能求出它出现的次数了，这样只能过部分样例，果然还是给卡住了，query调用的越多构造数组+排序的时间开销就会大很多，所以就超时了。

刚开始看灵神的代码理解起来还有点费劲，但是看完之后感觉给了我一个二分的一个很新颖的点，它是首先用哈希表来保存每个数出现的下标，用个列表存起来，所以哈希表的类型是`unordered_map<int, vector<int>> pos;`代表的是值到对应下标的映射集，这个就很巧妙！为什么呢？因为每个映射集是有序的！这样二分的就不再是value了而是二分的下标！也就是这里的left和right，我天哪真妙！