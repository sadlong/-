#  练习赛合集

##  力扣

###  双周赛135

####  3222.求出硬币游戏的玩家(数学、博弈)

```cpp
class Solution {
public:
    string losingPlayer(int x, int y) {
        return min(x, y/4)%2 ? "Alice" : "Bob";
    }
};
```



```go
func losingPlayer(x int, y int) string {
    ans := min(x, y/4)%2
    if ans&1 == 1 {
        return "Alice"
    } else {
        return "Bob"
    }
}
```

这一题吧，`min(x, y/4)%2`的用处就是求出这些硬币的最大轮数，因为这里的115只能由1个75和4个10构成



####  3223.操作后字符串的最短长度(哈希表)

```cpp
class Solution {
 public://3---1 4---1 5---2   6---2  7---3 8---3
    int minimumLength(string s) {
        vector<int> hash(26, 0);//字母---个数
        for(char c : s) {
            hash[c-'a']++;
        }

        int cnt = 0;
        for(int i = 0; i < 26; i++) {
            if(hash[i] >= 3) {
                cnt += (hash[i]-1)/2;
            }
        }
        return s.size()-2*cnt;
    }
};
```



```go
func minimumLength(s string) int {
    hash := make([]int, 26)
    for _, x := range s {
        hash[x-'a']++
    }

    cnt := 0
    for i := range hash {
        if hash[i] >= 3 {
            cnt += (hash[i]-1)/2
        }
    }
    return len(s)-2*cnt
}
```

通过哈希表统计每个字符出现的个数，然后枚举哈希表元素，出现超过3次的就能删除操作，删除次数的通式为`(hash[i]-1)/2`累加到cnt中



####  3224.使差值相等的最少数组改动次数(差分数组)

**枚举法**

```cpp
class Solution {
public:
    int minChanges(vector<int>& nums, int k) {
        vector<int> cnt(k+1), cnt2(k+1);
        int n = nums.size();
        for(int i = 0; i < n/2; i++) {
            int p = nums[i], q = nums[n-1-i];
            if(p > q) swap(p, q);   //保证p <= q
            cnt[q-p]++;
            cnt2[max(q, k-p)]++;
        }

        int ans = n;//修改次数不可能超过n
        int sum2 = 0;   //统计有多少对(p, q)都要改
        for(int x = 0; x <= k; x++) {
            //其它n/2-cnt[x]对(p, q)至少要修改一个数，在此基础上，有额外的sum2对(p, q)还要再改一个数
            ans = min(ans, n/2-cnt[x]+sum2);

            //对于后面更大的x，当前的这cnt2[x]对(p, q)都要改
            sum2 += cnt2[x];
        }

        return ans;
    }
};
```



**差分数组**

```cpp
class Solution {
public:
    //双周赛135
    int minChanges(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> d(k+2);
        for(int i = 0; i < n/2; i++) {
            int p = nums[i], q = nums[n-1-i];
            if(p > q) swap(p, q);
            int x = q-p, mx = max(q, k-p);
            d[0]++;
            d[x]--;
            d[x+1]++;
            d[mx+1]--;
            d[mx+1]+=2;
        }
        partial_sum(d.begin(), d.end(), d.begin());
        return ranges::min(d);
    }
};
```

其实不是很会。。。



###  周赛407

####  3226.使两个整数相等的位更改次数(位运算)

```cpp
class Solution {
public:
    int minChanges(int n, int k) {
        return (n&k) != k ? -1 : __builtin_popcount(n^k);
    }
};
```



```go
func minChanges(n int, k int) int {
    if n&k != k {
        return -1
    }

    return bits.OnesCount(uint(n^k))
}
```

根据题意发现：如果能够更改，那么从集合的角度来看k一定要是n的子集，所以用`n&k!=k`的话直接返回-1表示无法位次修改。如果k是n的子集，那么只需要求出n^k的二进制1的个数就是需要更改的次数。



####  3227.字符串元音游戏(脑经急转弯)

```cpp
class Solution {
public:
    bool doesAliceWin(string s) {
        int cnt = 0;
        for(char c : s) {
            if(c == 'a' || c == 'e' || c == 'i' || c =='o' || c == 'u') cnt++;
        }

        return cnt == 0 ? false : true;
    }
};
```



```go
func doesAliceWin(s string) bool {
    cnt := 0
    for _, c := range s {
        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {
            cnt++
        }
    }
    if cnt == 0 {
        return false
    }
    return true
}
```

在牛客上做过类似的题目哈哈哈，这一题写出来的时间还是很短的，很爽！看到评论区有人模拟出来的，就感觉自己成就感出来了哈哈哈。这一题只需要枚举一次字符串s看看里面有多少个元音字母，元音字母个数为0返回false，不为0就返回true就行啦



####  3228.将1移动到末尾的最大操作次数

```cpp
class Solution {
public:
    int maxOperations(string s) {
        int ans = 0, cnt = 0;
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '0') {
                if(i > 0 && s[i] != s[i-1]) ans += cnt;
            }
            else cnt++;
        }
        return ans;
    }
};
```



```go
func maxOperations(s string) int {
    ans, cnt := 0, 0
    for i := range s {
        if s[i] == '0' {
            if i > 0 && s[i] != s[i-1] {
                ans += cnt
            }
        } else {
            cnt++
        }
    }
    return ans
}
```

这一题和之前做过的每日一题很像，就是黑白棋子交换位置的步数，灵神用堵车来形象的展现出来，最后的代码其实都差不多啦哈哈哈，能在训练赛ac题目并且解法和大佬们一样真的很爽！



####  3229.使数组等于目标数组所需的最少操作次数(差分数组)

```cpp
class Solution {
public:
    long long minimumOperations(vector<int>& nums, vector<int>& target) {
        long long s = target[0]-nums[0];
        long long ans = abs(s);
        for(int i = 1; i < nums.size(); i++) {
            int k = (target[i]-target[i-1])-(nums[i]-nums[i-1]);
            if(k > 0) ans += s >= 0 ? k : max(k+s, 0LL);
            else ans -= s <= 0 ? k : min(k+s, 0LL);
            s += k;
        }
        return ans;
    }
};
```

这个题用到了差分数组，比赛的时候其实想到了使用差分数组，但是看到这是困难题还是选择的放弃，没有尝试去写，今天题解看到这里也没有啥心思去想这个困难题了，等到再刷到差分数组的时候再回过头来看看吧，这里就先贴个答案咯



###  周赛408

####  判断是否可以赢得数字游戏

```cpp
class Solution {
public:
    bool canAliceWin(vector<int>& nums) {
        int s1 = 0, s2 = 0;
        for(int n : nums) {
            if(n < 10) s1 += n;
            else s2 += n;
        }
        return s1 != s2;
    }
};
```

分为两种情况，s1>s2或s1<s2，所以只要s1不等于s2即可



####  统计不是特殊数字的数字数量(前缀和、线性筛、打表找规律)

```cpp
class Solution {
public:
    int nonSpecialCount(int l, int r) {
        //打表 观察数据特点发现规律
        // for(int i = 1; i < 1001; i++) {
        //     int cnt = 0;
        //     for(int j = 1; j < i; j++) {
        //         if(i%j == 0) cnt++;
        //     }
        //     if(cnt == 2) cout << i << " " << sqrt(i) << endl;
        // }

        const int mx = 35000;
        vector<int> pi(mx+1);
        //int pi[mx+1]
        for(int i = 2; i <= mx; i++) {
            if(pi[i] == 0) {    //是质数
                pi[i] = pi[i-1]+1;
                for(int j = i*i; j <= mx; j+=i) {
                    pi[j] = -1; //标记i的倍数为合数
                }
            } else {
                pi[i] = pi[i-1];
            }
            //cout << pi[i] << " ";
        }

        return r-l+1-(pi[(int)sqrt(r)]-pi[(int)sqrt(l-1)]);
    }
};
```



```go
func nonSpecialCount(l int, r int) int {
    mx := 35000
    presum := make([]int, mx+1)
    for i := 2; i <= mx; i++ {
        if presum[i] == 0 {
            presum[i] = presum[i-1]+1
            for j := i*i; j <= mx; j += i {
                presum[j] = -1
            }
        } else {
            presum[i] = presum[i-1]
        }
    }

    //go的sqrt用法，必须是float64类型
    cntR := presum[int(math.Sqrt(float64(r)))]
    cntL := presum[int(math.Sqrt(float64(l-1)))]
    return r-l+1-(cntR-cntL)
}
```

很好的一道题！检测出了我很多不会的地方！再次巩固了一下前缀和，这里之所以用到前缀和就是要求区间计数问题，[l,r]的区间计数要转换成[0,r]-[0,l-1]的问题，这样就是前缀和的样子了。然后就是打表通常是用来发掘数之间的关系的，通过打表，符合特殊数字的数是质数的平方，这样就将题目的意思转化成求区间[sqrt(l),sqrt(r)]的质数个数，这个转化确实是想不到，做不出来情有可原吧。。。





###  周赛411

####  统计满足k约束的子字符串数量I(枚举右端点、滑动窗口)

```cpp
class Solution {
public:
    int countKConstraintSubstrings(string s, int k) {
        int ans = 0, cnt[2]{}, left = 0;
        for(int i = 0; i < s.size(); i++) {
            cnt[s[i]&1]++;
            while(cnt[0] > k && cnt[1] > k) cnt[s[left++]&1]--;
            ans += i-left+1;
        }
        return ans;
    }
};
```



```go
func countKConstraintSubstrings(s string, k int) int {
    ans, left := 0, 0
    cnt := make([]int, 2)
    for i := range s {
        cnt[s[i]&1]++
        for cnt[0] > k && cnt[1] > k {
            cnt[s[left]&1]--
            left++
        }
        ans += i-left+1
    }
    return ans
}
```

比赛的时候其实也是想到了这个想法，就是枚举右端点，之前做过类似的子字符串数量的问题，就是建立了右端点和左端点的关系来求子字符串数量，这样也不会在求的过程中重复计算，就是在写的过程中不知道如何实现，卡了我好久好久以至于这一次周赛一题未写。这里创建的cnt数组很精妙，这是我没有想到的，cnt数组的创建就简化了很多操作，也变得简洁了很多

















##  牛客

###  周赛51

####  C.小红充电

```cpp
#include <bits/stdc++.h>

using namespace std;


void solve(){
	long double ans = 0;
    long double x, y, t, a, b, c;
	
	cin >> x >> y >> t >> a >> b >> c;
	//超级充电 不能玩手机 
	if(x <= t) ans = 1.0*(100-x)/c;
    else ans = min(1.0*(100-x)/b, 1.0*(x-t)/y + 1.0*(100-t)/c);
	cout << ans << "\n";
}

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    cout<<fixed<<setprecision(15);
	
	int t = 1;
	//cin >> t;
	while(t--) solve();
	
	return 0;
}
```

又是被暴击的一天，这其实也就算一道阅读理解题吧，错误的原因在于两点：1、`else ans = min(1.0*(100-x)/b, 1.0*(x-t)/y + 1.0*(100-t)/c);`在这一句中我的答案将min写成了max，`1.0*(100-t)/c`写成了`1.0*(100-x)/c`，这算在自己的粗心上面吧，还是挺浮躁的；2、知识盲区，根据题中所给的输出描述，我无法表达出来，以至于没能通过全部样例，这里的解法就在于`cout<<fixed<<setprecision(15);`，括号中的15写成6就足够了，这也就是考虑到double的精确问题，这一条语句可以让double输出小数点后15位。



####  D.小红的gcd

```cpp
#include <bits/stdc++.h>

using namespace std;

long long gcd(long long a, long long b) {
	return b == 0 ? a : gcd(b, a%b);
}

void solve(){
	string aa;
	long long a = 0, b = 0;
	cin >> aa >> b;
	for(char c : aa) {
		a = (a*10+(c-'0'))%b;
	}
	cout << gcd(a, b);
}

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
	//cin >> t;
	while(t--) solve();
	
	return 0;
}
```

与以往不同的gcd而言，这一题主要是数据范围的扩大，导致我不知道怎么写。由于 gcd(*a*,*b*)=gcd(*a*−*b*,*b*)=gcd(*a*−2*b*,*b*)=⋯=*g**c**d*(*a*(mod*b*),*b*)，因此我们只需计算𝑎(mod𝑏)*a*(mod*b*)的值 。这就是将这一题a的值范围降下来的操作。好在gcd函数还是记下来怎么写了，C++可以直接调用`__gcd(int a,int b)`。





####  E.小红走矩阵

```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int N=1000;
const int mod=998244353;

int g[N][N], ans[N][N];
int n;

//上左下右 
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, -1, 0, 1};

struct node {
	int x, y, val;
};

void bfs() {
	memset(ans, INF, sizeof(ans));
	deque<node> dq;
	dq.push_back({1, 1, g[1][1]});
	while(!dq.empty()) {
		node now = dq.front();
		dq.pop_front();
		
        //不加会超时
		if(ans[now.x][now.y] < now.val) continue;
		
		for(int i = 0; i < 4; i++) {
			int xx = now.x+dx[i];
			int yy = now.y+dy[i];
			
			//在矩阵范围内 
			if(xx >= 1 && xx <= n && yy >= 1 && yy <= n) {
				int nowval = max(now.val, g[xx][yy]);
                //维护最小路径，如果当前这个节点val较小，那么入队参与遍历
				if(nowval < ans[xx][yy]) {
					ans[xx][yy] = nowval;
					dq.push_back({xx, yy, nowval});
				}
			}
		}
	}
}

void solve(){
	
	cin >> n;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			cin >> g[i][j];
		}
	}
	
	bfs();
	cout << ans[n][n] << endl << INF;
}

signed main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	
	int t = 1;
	//cin >> t;
	while(t--) solve();
	
	return 0;
}
```

广度优先搜索，确实是一道很标准的广度优先搜索，第一次写的时候确实是想到了，但是不知道怎么实现，与以前不同的是这里多了一个结构体定义，也就是将横纵坐标和val封装起来我认为重要的地方就在于这几个if语句，模板其实都大差不差，不同的地方就是在模板里加入别的语句





###  周赛53

####  A.小红小紫投硬币

```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int N=1000;
const int mod=998244353;


void solve(){
	int n;
	cin >> n;
	cout << 0.5; 
}

signed main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cout << fixed << setprecision(6); 
	
	int t = 1;
	//cin >> t;
	while(t--) solve();
	
	return 0;
}
```

这一题差点没做出来，就是怪吓人的，签到题还是不需要想那么多，其实就相当于前n次抵消掉了，然后求一次抛硬币正面朝上的概率，所以无论n是多少，只需要输出0.5就行了



####  B.小红的字符串

```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int N=1000;
const int mod=998244353;


void solve(){
	string s;
	cin >> s;
    int n = s.size(), ans = 0;
    for(int i = 0; i < n-1-i; i++) {
        int t = abs(s[i]-s[n-1-i]);
        ans += min(t, 26-t);
    }
	cout << ans;
}

signed main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cout << fixed << setprecision(6); 
	
	int t = 1;
	//cin >> t;
	while(t--) solve();
	
	return 0;
}
```

也是发现到了，自己对这种字符串题的转换还是有点不太会，当时一直想着取模去了，然后就不想写了，牛客的周赛以后还是放一边吧，赛后再写得了。将字符的操作次数排列成一个环，也就是a-z的一个环，操作次数也就是0-25。这里也是用i和n-1-i表示了字符的对称位置，值得学一学，循环的边界条件也是`i<n-1-i`，给出一个方便记忆的方法：如何确定n-1-i?---将i和n-1-i求和为n-1，那么你就正确表示了i的对称位置，n-1也就是字符串的最后一个位置。



####  C.小红的01消除

```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long
const ll INF = 0x3f3f3f3f3f3f3f3f;
const int N=1000;
const int mod=998244353;


void solve(){
	int n;
	cin >> n;
	string s;
	cin >> s;
	int x, y, z;
	cin >> x >> y >> z;
	int ans = 0, cnt0 = 0;
	for(char c : s) {
		if(c == '0') cnt0++;
		else if(cnt0) cnt0--, ans++;
	}
	cout << min(ans, y);
}

signed main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cout << fixed << setprecision(6); 
	
	int t = 1;
	//cin >> t;
	while(t--) solve();
	
	return 0;
}
```

自己写的时候有两种思路，一种是字符串模拟栈，但是想着这样写挺麻烦的，最后想到了一个先不管前面的1，然后记录0和1的个数的方法，但是只能通过85%，问题就在于可能会出现"10"的情况，其实也算是一个贪心思路。但是看了题解的贪心思路才是妙，它的方法解决了"10"的情况，也就是对应的elseif那一行